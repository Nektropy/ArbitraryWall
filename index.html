<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>ä¾¿ç­¾æŠ•ç¨¿å¢™</title>
    <!-- æ€§èƒ½ä¼˜åŒ– -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="dns-prefetch" href="https://www.transparenttextures.com">
    <!-- ä½¿ç”¨ marked è§£æ Markdown (è½»é‡, å®‰å…¨) -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js" defer></script>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        body {
            background: #2d241e;
            font-family: 'Segoe UI', 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            touch-action: pan-x pan-y pinch-zoom; /* å…è®¸å•æŒ‡å¹³ç§» + åŒæŒ‡ç¼©æ”¾ */
        }

        /* å…¨å±å®¹å™¨ */
        .wall-wrapper {
            width: 100vw;
            height: 100vh;
            overflow: hidden;  /* å®Œå…¨ç¦ç”¨æ»šåŠ¨ï¼Œç”¨ transform æ§åˆ¶ */
            position: relative;
            touch-action: none;
            background: linear-gradient(to bottom, #87ceeb, #b0e0e6);
            cursor: grab;
        }
        .wall-wrapper:active {
            cursor: grabbing;
        }

        /* å·¨å¢™ â€” èƒŒæ™¯å›¾ç‰‡é“¾æ¥åœ¨æ­¤ä¿®æ”¹ */
        .wall {
            position: absolute;
            left: 50%; top: 50%;
            width: 10000px;
            height: 10000px;
            background-image: url('https://www.transparenttextures.com/patterns/old-wall.png');
            background-color: #b08a67;
            background-repeat: repeat;
            background-size: 300px 300px;
            box-shadow: inset 0 0 0 4px #5a3f2e;
            transform-origin: center center;  /* ä¸­å¿ƒç¼©æ”¾ï¼Œé…åˆ translate(-50%, -50%) */
            transform: translate(-50%, -50%) scale(1);
            will-change: transform;
            cursor: grab;
            backface-visibility: hidden;  /* å¼ºåˆ¶ GPU å±‚ */
            -webkit-backface-visibility: hidden;
        }
        .wall:active {
            cursor: grabbing;
        }
        


        /* ä¾¿ç­¾ç»Ÿä¸€æ ·å¼ â€” å°ºå¯¸å¯ä¿®æ”¹ */
        .note {
            position: absolute;
            width: 240px;
            min-height: 200px;
            background-color: #fffacd;
            border-bottom: 4px solid #d4b57e;
            border-right: 4px solid #c7a36b;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fffff0 inset;
            padding: 18px 16px 32px 20px;  /* bottom ç•™ç»™ç½²åè¡Œ */
            font-family: 'Segoe UI', 'Comic Sans MS', 'Marker Felt', cursive;
            font-size: 0.95rem;
            line-height: 1.5;
            color: #2d241b;
            border-radius: 5px 20px 12px 8px;
            transform-origin: 0 0;
            transition: transform 0.25s ease-out, box-shadow 0.1s, filter 0.1s;
            cursor: grab;
            word-wrap: break-word;
            z-index: 1;
            will-change: transform;  /* æ”¹ä¸º transformï¼Œæ‹–åŠ¨ç”¨ translate */
            overflow: hidden;
            touch-action: none;
            contain: layout style;   /* éš”ç¦» reflow å½±å“ */
        }
        
        /* å¸¦å›¾ç‰‡èƒŒæ™¯çš„ä¾¿ç­¾ */
        .note.has-image-bg {
            background-color: #d6e8f5; /* å›¾ç‰‡åŠ è½½å‰/å¤±è´¥çš„é™çº§è‰² */
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
            position: relative;
        }
        /* å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶çš„æç¤º */
        .note.has-image-bg.img-error {
            background-color: #f0e8d8;
            background-image: none !important;
        }
        .note.has-image-bg.img-error::after {
            content: "ğŸ–¼ï¸";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            opacity: 0.3;
            pointer-events: none;
        }
        
        /* å›¾ç‰‡èƒŒæ™¯ä¾¿ç­¾çš„å†…å®¹è¦†ç›–å±‚ */
        .note.has-image-bg .note-content {
            background: rgba(255, 255, 255, 0.88);
            padding: 15px;
            border-radius: 4px;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }
        
        /* ä¾¿ç­¾æ ·å¼ - yellow */
        .note.style-yellow {
            background-color: #fffacd; /* å„ style-* / has-image-bg ç±»ä¼šè¦†ç›– */
            border-bottom: 4px solid #d4b57e;
            border-right: 4px solid #c7a36b;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fffff0 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - blue */
        .note.style-blue {
            background: #e6f7ff;
            background: linear-gradient(145deg, #f0f9ff, #d6f0ff);
            border-bottom: 4px solid #91d5ff;
            border-right: 4px solid #69c0ff;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f0f9ff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - green */
        .note.style-green {
            background: #f6ffed;
            background: linear-gradient(145deg, #f9fff2, #e8f5e8);
            border-bottom: 4px solid #b7eb8f;
            border-right: 4px solid #95de64;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f9fff2 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - pink */
        .note.style-pink {
            background: #fff0f6;
            background: linear-gradient(145deg, #fff5f8, #ffd6e7);
            border-bottom: 4px solid #ffadd2;
            border-right: 4px solid #ff85c0;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fff5f8 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - red */
        .note.style-red {
            background: #fff0f0;
            background: linear-gradient(145deg, #fff5f5, #ffd6d6);
            border-bottom: 4px solid #ff8585;
            border-right: 4px solid #ff5c5c;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fff5f5 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - purple */
        .note.style-purple {
            background: #f9f0ff;
            background: linear-gradient(145deg, #fcf5ff, #f0d6ff);
            border-bottom: 4px solid #d3adf7;
            border-right: 4px solid #b37feb;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fcf5ff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - orange */
        .note.style-orange {
            background: #fff7e6;
            background: linear-gradient(145deg, #fffbf0, #ffd6b3);
            border-bottom: 4px solid #ffc599;
            border-right: 4px solid #ffa94d;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fffbf0 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - teal */
        .note.style-teal {
            background: #e6fffb;
            background: linear-gradient(145deg, #f0fffb, #b3ffe6);
            border-bottom: 4px solid #85e6d9;
            border-right: 4px solid #5cdbd3;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f0fffb inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - indigo */
        .note.style-indigo {
            background: #f0f5ff;
            background: linear-gradient(145deg, #f5f9ff, #d6e4ff);
            border-bottom: 4px solid #adc6ff;
            border-right: 4px solid #86a8ff;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f5f9ff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - lime */
        .note.style-lime {
            background: #fafff0;
            background: linear-gradient(145deg, #fdfef9, #e8f5c8);
            border-bottom: 4px solid #e6ff70;
            border-right: 4px solid #d3f975;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fdfef9 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - cyan */
        .note.style-cyan {
            background: #e6ffff;
            background: linear-gradient(145deg, #f0ffff, #b3ffff);
            border-bottom: 4px solid #85ffff;
            border-right: 4px solid #5cdede;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f0ffff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - amber */
        .note.style-amber {
            background: #fffbe6;
            background: linear-gradient(145deg, #fefcf0, #ffefb3);
            border-bottom: 4px solid #ffd591;
            border-right: 4px solid #ffc14d;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fefcf0 inset;
        }
        
        /* è‡ªå®šä¹‰é¢œè‰²ä¾¿ç­¾ */
        .note.custom-color {
            border-bottom: 4px solid rgba(0,0,0,0.2);
            border-right: 4px solid rgba(0,0,0,0.3);
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 rgba(255,255,255,0.3) inset;
        }
        .note:hover {
            filter: brightness(1.02);
            box-shadow: 10px 10px 22px rgba(0,0,0,0.5), 0 0 0 2px #fceeb6;
            cursor: grab;
        }
        .note:active {
            cursor: grabbing;
            z-index: 9999 !important;
            box-shadow: 14px 14px 25px rgba(0,0,0,0.6);
        }
        /* å°æŠ˜è§’ */
        .note::before {
            content: "";
            position: absolute;
            top: 0;
            right: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 35px 35px 0;
            border-color: transparent #cfb07c transparent transparent;
            opacity: 0.6;
            pointer-events: none;
        }
        /* ä¾¿ç­¾å†…å®¹åŒºåŸŸ â€” æ¸²æŸ“ Markdown */
        .note-content {
            display: block;
            width: 100%;
            white-space: normal;
            word-break: break-word;
        }
        /* â”€â”€ è¿˜åŸè¢« * {margin:0;padding:0} æ¸…é›¶çš„ Markdown å…ƒç´ æ ·å¼ â”€â”€ */
        .note-content p {
            margin: 0 0 8px 0;
        }
        .note-content h1, .note-content h2, .note-content h3,
        .note-content h4, .note-content h5, .note-content h6 {
            font-weight: bold;
            margin: 6px 0 4px 0;
            line-height: 1.3;
        }
        .note-content h1 { font-size: 1.3em; }
        .note-content h2 { font-size: 1.15em; }
        .note-content h3 { font-size: 1.05em; }
        .note-content strong, .note-content b { font-weight: bold; }
        .note-content em, .note-content i { font-style: italic; }
        .note-content s, .note-content del { text-decoration: line-through; }
        .note-content ul, .note-content ol {
            margin: 4px 0 4px 18px;
            padding: 0;
        }
        .note-content ul { list-style: disc; }
        .note-content ol { list-style: decimal; }
        .note-content li { margin: 2px 0; }
        .note-content blockquote {
            border-left: 3px solid #c9a86c;
            margin: 6px 0 6px 4px;
            padding: 2px 0 2px 10px;
            color: #6b4f2a;
            font-style: italic;
        }
        .note-content code {
            background: rgba(0,0,0,0.08);
            padding: 1px 5px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.88em;
        }
        .note-content pre {
            background: rgba(0,0,0,0.08);
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 6px 0;
        }
        .note-content pre code {
            background: none;
            padding: 0;
        }
        .note-content hr {
            border: none;
            border-top: 1px dashed #c9a86c;
            margin: 8px 0;
        }
        .note-content a {
            color: #a55808;
            text-decoration: underline;
            cursor: pointer;
        }


        /* ä¾¿ç­¾ç½²å â€” ç»å¯¹å®šä½å›ºå®šäºå³ä¸‹è§’ */
        .note-author {
            position: absolute;
            bottom: 8px;
            right: 12px;
            left: 20px;         /* å·¦è¾¹ç•Œï¼Œé˜²æ­¢é•¿åå­—æº¢å‡º */
            font-size: 0.72rem;
            color: rgba(60,40,20,0.55);
            text-align: right;
            font-style: italic;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            pointer-events: none;
            border-top: 1px dashed rgba(0,0,0,0.12);
            padding-top: 4px;
            line-height: 1.3;
        }

        /* ç¼©æ”¾æ§åˆ¶æ¡ â€” å³ä¸‹è§’å›ºå®šï¼Œç§»åŠ¨ç«¯å‹å¥½ */
        .zoom-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(45, 36, 30, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 12px 20px;
            border-radius: 40px;
            border: 2px solid #bb9d7b;
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 20000;
            color: #f7e3c2;
            box-shadow: 0 10px 25px rgba(0,0,0,0.6);
            font-size: 1rem;
            touch-action: manipulation;
        }
        .zoom-control label {
            font-size: 1.3rem;
            font-weight: bold;
            line-height: 1;
        }
        .zoom-control input {
            width: 200px;
            height: 10px;
            background: #4f3e2e;
            border-radius: 20px;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            touch-action: manipulation;
        }
        .zoom-control input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 28px;
            height: 28px;
            background: #f7d9a0;
            border-radius: 50%;
            border: 2px solid #7b5b3e;
            box-shadow: 0 2px 8px black;
            cursor: grab;
            touch-action: manipulation;
        }
        .zoom-control input::-moz-range-thumb {
            width: 28px;
            height: 28px;
            background: #f7d9a0;
            border-radius: 50%;
            border: 2px solid #7b5b3e;
            cursor: grab;
            touch-action: manipulation;
        }
        .zoom-control span {
            min-width: 65px;
            font-size: 1.3rem;
            background: #2d1f14;
            padding: 5px 12px;
            border-radius: 40px;
            text-align: center;
            border: 1px solid #c8a87c;
        }

        /* ä¿¡æ¯å¼¹çª— */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300000;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            padding: 15px;
        }
        .modal-box {
            background: #fef7e9;
            max-width: 500px;
            width: 100%;
            padding: 25px 20px;
            border-radius: 40px 15px 40px 15px;
            box-shadow: 0 30px 40px rgba(0,0,0,0.6), 0 10px 0 #bc9f7e inset;
            text-align: left;
            border: 5px solid #dac29c;
            font-size: 1rem;
            color: #3f2e1f;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-box h2 {
            margin: 0 0 15px 0;
            font-weight: 400;
            color: #4a3322;
            font-size: 2rem;
            border-bottom: 2px dashed #b48c65;
            padding-bottom: 8px;
        }
        .modal-box ul {
            margin: 15px 0;
            padding-left: 25px;
        }
        .modal-box li {
            margin: 8px 0;
        }
        .modal-box code {
            background: #2d241e;
            color: #fadfad;
            padding: 2px 8px;
            border-radius: 30px;
            font-family: monospace;
            font-size: 0.85rem;
        }
        .modal-close {
            background: #b48c65;
            border: none;
            border-bottom: 5px solid #7b5b3e;
            padding: 12px 30px;
            border-radius: 40px;
            font-size: 1.3rem;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.1s;
            margin-top: 15px;
            display: block;
            margin-left: auto;
            touch-action: manipulation;
        }
        .modal-close:active {
            transform: translateY(4px);
            border-bottom-width: 2px;
        }
        .hidden {
            display: none;
        }

        /* ç§»åŠ¨ç«¯è°ƒæ•´æ»‘å—å®½åº¦ */
        @media (max-width: 600px) {
            .zoom-control {
                padding: 10px 15px;
                gap: 10px;
                bottom: 15px;
                right: 15px;
            }
            .zoom-control input {
                width: 130px;
            }
            .zoom-control span {
                min-width: 55px;
                font-size: 1.1rem;
            }
            .zoom-control label {
                font-size: 1.1rem;
            }
        }
    
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            .note {
                font-size: 1rem;        /* å­—å·ç¨å¤§ï¼Œè§¦æ‘¸å‹å¥½ */
                min-height: 180px;
            }
            .zoom-control {
                bottom: 16px;
                right: 16px;
                padding: 10px 16px;
                font-size: 0.9rem;
            }
            .zoom-control input {
                width: 140px;
            }
        }
</style>
</head>
<body>
    <!-- æ»šåŠ¨å®¹å™¨ -->
    <div class="wall-wrapper" id="wallWrapper">
        <!-- å·¨å¢™ (10000x10000) -->
        <div class="wall" id="wall"></div>
    </div>

    <!-- ç¼©æ”¾æ»‘å— (å³ä¸‹è§’) -->
    <div class="zoom-control">
        <label>ğŸ”</label>
        <input type="range" id="zoomSlider" min="0.2" max="3" step="0.02" value="1">
        <span id="zoomPercent">100%</span>
    </div>

    <!-- å¼¹çª— (ä½¿ç”¨è¯´æ˜) -->
    <div class="modal-overlay" id="infoModal">
        <div class="modal-box">
            <h2>ğŸ§± ä¾¿ç­¾æŠ•ç¨¿å¢™</h2>
            <ul>
                <li><strong>â• æ·»åŠ æŠ•ç¨¿</strong>ï¼šåœ¨ <code>notes-data.json</code> çš„ <code>notes</code> æ•°ç»„è¿½åŠ æ–°å¯¹è±¡ã€‚</li>
                <li><strong>ğŸ‘¤ ç½²åå­—æ®µ</strong>ï¼š<code>author</code>ï¼ˆæ˜µç§°ï¼‰ã€<code>avatar</code>ï¼ˆå¤´åƒé“¾æ¥ï¼‰ã€<code>from</code>ï¼ˆæ¥æºå¹³å°ï¼‰ã€‚</li>
                <li><strong>ğŸ¨ ä¾¿ç­¾é¢œè‰²</strong>ï¼š<code>style</code> å¡«é¢œè‰²åï¼ˆyellow/blueâ€¦ï¼‰ã€<code>#hex</code> æˆ–å›¾ç‰‡é“¾æ¥ã€‚</li>
                <li><strong>ğŸ“ æ”¯æŒ Markdown</strong>ï¼šç²—ä½“ã€æ–œä½“ã€åˆ—è¡¨ã€é“¾æ¥ã€ä»£ç å—å‡å¯ç”¨ã€‚</li>
                <li><strong>ğŸ” ç¼©æ”¾</strong>ï¼šå³ä¸‹è§’æ»‘å— / é¼ æ ‡æ»šè½® / ç§»åŠ¨ç«¯åŒæŒ‡ã€‚</li>
                <li><strong>ğŸ–±ï¸ æ‹–åŠ¨</strong>ï¼šå•æŒ‡/é¼ æ ‡æ‹–åŠ¨å¢™é¢ï¼Œä¾¿ç­¾ä¹Ÿå¯å•ç‹¬æ‹–æ‹½ã€‚</li>
            </ul>
            <button class="modal-close" id="closeModalBtn">å¼€å§‹æ¢ç´¢ ğŸš€</button>
        </div>
    </div>
    </div>

    <script>
        (function() {
            // å¢™é¢å¤§å°é…ç½® - å¯ä»¥è½»æ¾ä¿®æ”¹è¿™é‡Œæ¥æ”¹å˜å¢™é¢å°ºå¯¸
            const WALL_WIDTH = 10000;
            const WALL_HEIGHT = 10000;

            const wall = document.getElementById('wall');
            const wrapper = document.getElementById('wallWrapper');
            const slider = document.getElementById('zoomSlider');
            const zoomSpan = document.getElementById('zoomPercent');

            // è®¾ç½®å¢™é¢å¤§å°
            wall.style.width = WALL_WIDTH + 'px';
            wall.style.height = WALL_HEIGHT + 'px';

            let maxZIndex = 1000;
            let currentScale = 1.0; // å½“å‰ç¼©æ”¾å€¼

            // å·¥å…·å‡½æ•°ï¼šéšæœºèŒƒå›´
            const random = (min, max) => Math.random() * (max - min) + min;

            // â”€â”€ å¯è§å­—ç¬¦è®¡æ•°ï¼šå‰¥ç¦»æ‰€æœ‰ Markdown è¯­æ³•ç¬¦å·å’Œ URLï¼Œåªæ•°å®é™…å†…å®¹ â”€â”€
            const MAX_CHARS = 100;
            function countVisible(text) {
                if (!text) return 0;
                return text
                    .replace(/!?\[([^\]]*?)\]\([^)]*?\)/g, '$1') // é“¾æ¥/å›¾ç‰‡ï¼šåªä¿ç•™æ˜¾ç¤ºæ–‡å­—
                    .replace(/```[\s\S]*?```/g, m => m.slice(3, -3).trim()) // ä»£ç å—
                    .replace(/`([^`]*?)`/g, '$1')   // è¡Œå†…ä»£ç 
                    .replace(/^#{1,6}\s+/gm, '')     // æ ‡é¢˜ç¬¦å·
                    .replace(/[*_~]{1,3}/g, '')      // ç²—ä½“/æ–œä½“/åˆ é™¤çº¿ç¬¦å·
                    .replace(/^>\s*/gm, '')           // å¼•ç”¨ç¬¦å·
                    .replace(/^[-*+]\s+/gm, '')       // æ— åºåˆ—è¡¨ç¬¦å·
                    .replace(/^\d+\.\s+/gm, '')       // æœ‰åºåˆ—è¡¨ç¬¦å·
                    .replace(/^[-*_]{3,}\s*$/gm, '')  // æ°´å¹³çº¿
                    .replace(/\n/g, '')               // æ¢è¡Œä¸è®¡å­—æ•°
                    .length;
            }

            function truncateText(text) {
                if (!text) return '';
                if (countVisible(text) <= MAX_CHARS) return text;
                // é€æ­¥æ‰«æåŸæ–‡ï¼Œè·³è¿‡ä¸è®¡å­—æ•°çš„éƒ¨åˆ†ï¼Œè¾¾åˆ°ä¸Šé™æ—¶æˆªæ–­
                let visible = 0;
                let i = 0;
                while (i < text.length && visible < MAX_CHARS) {
                    const rest = text.slice(i);
                    let m;
                    // é“¾æ¥/å›¾ç‰‡ [æ˜¾ç¤ºæ–‡å­—](url) â†’ åªè®¡æ˜¾ç¤ºæ–‡å­—
                    if ((m = rest.match(/^!?\[([^\]]*?)\]\([^)]*?\)/))) {
                        visible += m[1].length; i += m[0].length; continue;
                    }
                    // ä»£ç å— ```...```
                    if ((m = rest.match(/^```[\s\S]*?```/))) {
                        visible += m[0].slice(3,-3).trim().replace(/\n/g,'').length;
                        i += m[0].length; continue;
                    }
                    // è¡Œå†…ä»£ç  `...`
                    if ((m = rest.match(/^`([^`]*?)`/))) {
                        visible += m[1].length; i += m[0].length; continue;
                    }
                    // æ ‡é¢˜ç¬¦å· # ## ...ï¼ˆè¡Œé¦–ï¼‰
                    if ((m = rest.match(/^#{1,6}\s+/))) { i += m[0].length; continue; }
                    // ç²—ä½“/æ–œä½“/åˆ é™¤çº¿ç¬¦å·
                    if ((m = rest.match(/^[*_~]{1,3}/))) { i += m[0].length; continue; }
                    // å¼•ç”¨ç¬¦å· > ï¼ˆè¡Œé¦–ï¼‰
                    if ((m = rest.match(/^>\s*/))) { i += m[0].length; continue; }
                    // åˆ—è¡¨ç¬¦å·ï¼ˆè¡Œé¦–ï¼‰
                    if ((m = rest.match(/^[-*+]\s+|^\d+\.\s+/))) { i += m[0].length; continue; }
                    // æ°´å¹³çº¿
                    if ((m = rest.match(/^[-*_]{3,}\s*\n/))) { i += m[0].length; continue; }
                    // æ¢è¡Œä¸è®¡
                    if (text[i] === '\n') { i++; continue; }
                    visible++;
                    i++;
                }
                return text.slice(0, i) + 'â€¦';
            }

            // Markdown æ¸²æŸ“ï¼ˆå¸¦ç¼“å­˜ï¼‰
            function renderMarkdown(text) {
                if (typeof marked === 'undefined') return text;
                if (!mdCache.has(text)) {
                    try { mdCache.set(text, marked.parse(text)); } catch(e) { mdCache.set(text, text); }
                }
                return mdCache.get(text);
            }

            // marked å°±ç»ªåé‡æ–°æ¸²æŸ“ï¼ˆå¸¦ç¼“å­˜ï¼Œé¿å…é‡å¤è§£æï¼‰
            const mdCache = new Map();
            function rewireMarkdown() {
                if (typeof marked === 'undefined') return;
                document.querySelectorAll('.note-content[data-raw]').forEach(el => {
                    const raw = el.dataset.raw;
                    if (!mdCache.has(raw)) {
                        try { mdCache.set(raw, marked.parse(raw)); } catch(e) { mdCache.set(raw, raw); }
                    }
                    el.innerHTML = mdCache.get(raw);
                    delete el.dataset.raw;
                });
            }
            document.querySelector('script[src*="marked"]')
                ?.addEventListener('load', rewireMarkdown);


            // â”€â”€ å›¾ç‰‡èƒŒæ™¯æ‡’åŠ è½½ï¼ˆIntersection Observerï¼‰â”€â”€
            let imgObserver = null;
            function initImgObserver() {
                if (imgObserver) return;
                imgObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const note = entry.target;
                            const imgUrl = note.dataset.bgImg;
                            if (imgUrl) {
                                const img = new Image();
                                img.onload = () => {
                                    note.style.setProperty('background-image', `url("${imgUrl}")`, 'important');
                                    delete note.dataset.bgImg;
                                };
                                img.onerror = () => note.classList.add('img-error');
                                img.src = imgUrl;
                                imgObserver.unobserve(note);
                            }
                        }
                    });
                }, { rootMargin: '100px' });  // æå‰ 100px å¼€å§‹åŠ è½½
            }

            // åˆ›å»ºä¾¿ç­¾ï¼ˆæ”¯æŒ styleï¼šé¢œè‰²å / #hex / å›¾ç‰‡é“¾æ¥ï¼Œä»¥åŠå¯é€‰ author ç½²åï¼‰
            function createNote(mdText, left, top, rotate = null, style = 'yellow', author = '') {
                const note = document.createElement('div');
                note.className = 'note';

                // â”€â”€ èƒŒæ™¯æ ·å¼ â”€â”€
                if (typeof style === 'string') {
                    if (style.startsWith('http') || style.startsWith('//')) {
                        note.classList.add('has-image-bg');
                        note.dataset.bgImg = style;  // å­˜åˆ° data å±æ€§ï¼Œå»¶è¿ŸåŠ è½½
                        initImgObserver();
                        imgObserver.observe(note);  // è¿›å…¥è§†å£åæ‰åŠ è½½
                    } else if (style.startsWith('#')) {
                        note.classList.add('custom-color');
                        note.style.background = `linear-gradient(145deg, ${lightenColor(style, 5)}, ${darkenColor(style, 5)})`;
                    } else {
                        note.classList.add(`style-${style}`);
                    }
                } else {
                    note.classList.add('style-yellow');
                }

                // â”€â”€ æ—‹è½¬ & ä½ç½® â”€â”€
                const rot = (rotate !== null) ? rotate : random(-5, 6);
                note.style.transform = `rotate(${rot}deg)`;
                const noteLeft = left !== null ? left : random(200, WALL_WIDTH - 200);
                const noteTop  = top  !== null ? top  : random(200, WALL_HEIGHT - 200);
                note.style.left = noteLeft + 'px';
                note.style.top  = noteTop  + 'px';
                note.style.zIndex = Math.floor(random(10, 500));

                // â”€â”€ æ­£æ–‡å†…å®¹ â”€â”€
                const contentSpan = document.createElement('span');
                contentSpan.className = 'note-content';
                const truncated = truncateText(mdText);
                const html = renderMarkdown(truncated);
                contentSpan.innerHTML = html;
                // è‹¥ marked å°šæœªå°±ç»ªï¼ˆdeferï¼‰ï¼Œä¿å­˜åŸæ–‡ä¾› rewireMarkdown è¡¥æ¸²æŸ“
                if (html === truncated && truncated.trim()) {
                    contentSpan.dataset.raw = truncated;
                }
                note.appendChild(contentSpan);

                // â”€â”€ ç½²åï¼ˆæœ‰ author æ—¶æ˜¾ç¤ºï¼‰â”€â”€
                if (author && author.trim()) {
                    const authorEl = document.createElement('span');
                    authorEl.className = 'note-author';
                    authorEl.textContent = 'â€” ' + author.trim();
                    note.appendChild(authorEl);
                }

                makeDraggable(note);
                return note;
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šè°ƒæ•´é¢œè‰²äº®åº¦
            function lightenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
            }
            
            function darkenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R>255?255:R<0?0:R)*0x10000 + (G>255?255:G<0?0:G)*0x100 + (B>255?255:B<0?0:B)).toString(16).slice(1);
            }

            // â”€â”€ ä¾¿ç­¾æ‹–æ‹½ï¼šäº‹ä»¶å§”æ‰˜åˆ° wallï¼Œé¿å… N å¼ ä¾¿ç­¾ Ã— 2 ä¸ªç›‘å¬å™¨ â”€â”€
            // æ‹–æ‹½çŠ¶æ€ï¼ˆå…¨å±€å•ä¾‹ï¼ŒåŒæ—¶åªèƒ½æ‹–ä¸€å¼ ï¼‰
            let dragNote = null, dragStartX = 0, dragStartY = 0;
            let dragInitLeft = 0, dragInitTop = 0;
            let dragHasMoved = false;
            let dragVX = 0, dragVY = 0, dragLastX = 0, dragLastY = 0, dragLastT = 0;
            let dragRafId = null;
            // é¢„å­˜ä¾¿ç­¾å°ºå¯¸ï¼Œé¿å…æ‹–åŠ¨ä¸­åå¤è§¦å‘ layout
            const NOTE_W = 240, NOTE_H = 200;

            function noteDragStart(note, clientX, clientY) {
                dragNote = note;
                dragStartX = clientX; dragStartY = clientY;
                dragInitLeft  = parseFloat(note.style.left)  || 0;
                dragInitTop   = parseFloat(note.style.top)   || 0;
                dragLastX = clientX; dragLastY = clientY;
                dragLastT = Date.now();
                dragVX = 0; dragVY = 0;
                dragHasMoved = false;
                maxZIndex++;
                note.style.zIndex = maxZIndex;
                note.style.transition = 'none';
            }

            function noteDragMove(clientX, clientY) {
                if (!dragNote) return;
                const now = Date.now(), dt = now - dragLastT;
                if (dt > 0) {
                    dragVX = (clientX - dragLastX) / dt * 16;
                    dragVY = (clientY - dragLastY) / dt * 16;
                }
                dragLastX = clientX; dragLastY = clientY; dragLastT = now;

                const dx = clientX - dragStartX, dy = clientY - dragStartY;
                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragHasMoved = true;

                let newLeft = Math.min(WALL_WIDTH - 30,  Math.max(-NOTE_W + 30, dragInitLeft + dx));
                let newTop  = Math.min(WALL_HEIGHT - 30, Math.max(-NOTE_H + 30, dragInitTop  + dy));

                // rAF èŠ‚æµå†™ DOMï¼šæ‹–æ‹½ä¸­ç¦ç”¨ transitionï¼Œç”¨ translate å³æ—¶ç§»åŠ¨
                if (dragRafId) cancelAnimationFrame(dragRafId);
                dragRafId = requestAnimationFrame(() => {
                    if (dragNote) {
                        dragNote.style.transition = 'none';
                        dragNote.style.transform = `translate(${newLeft}px, ${newTop}px)`;
                    }
                });
            }

            function noteDragEnd() {
                if (!dragNote) return;
                cancelAnimationFrame(dragRafId);
                const note = dragNote;
                dragNote = null;
                dragRafId = null;
                if (!dragHasMoved) return;

                // è¯»å–å½“å‰ translate ä½ç½®
                const m = note.style.transform.match(/translate\(([^,]+)px, ([^)]+)px\)/);
                let curX = m ? parseFloat(m[1]) : 0;
                let curY = m ? parseFloat(m[2]) : 0;

                // åº”ç”¨é€Ÿåº¦è¡°å‡
                let finalX = Math.min(WALL_WIDTH-30, Math.max(-NOTE_W+30, curX + dragVX * 0.5));
                let finalY = Math.min(WALL_HEIGHT-30, Math.max(-NOTE_H+30, curY + dragVY * 0.5));

                // å†™å› left/topï¼Œæ¸…é™¤ translateï¼Œè®© transition æ¥ç®¡
                note.style.left = finalX + 'px';
                note.style.top  = finalY + 'px';
                note.style.transform = '';
                note.style.transition = ''; // æ¢å¤ CSS é»˜è®¤ transition
            }

            // wall å±‚ç»Ÿä¸€å§”æ‰˜ mousedown / touchstart
            function initNoteDrag() {
                wall.addEventListener('mousedown', (e) => {
                    const note = e.target.closest('.note');
                    if (!note || e.button !== 0) return;
                    if (e.target.closest('a')) return; // è¶…é“¾æ¥ä¸æ‹–
                    e.preventDefault(); e.stopPropagation();
                    noteDragStart(note, e.clientX, e.clientY);
                    document.addEventListener('mousemove', onDocMouseMove);
                    document.addEventListener('mouseup',  onDocMouseUp,  { once: true });
                });
                wall.addEventListener('touchstart', (e) => {
                    if (e.touches.length !== 1) return;
                    const note = e.target.closest('.note');
                    if (!note) return;
                    if (e.target.closest('a')) return;
                    e.preventDefault(); e.stopPropagation();
                    noteDragStart(note, e.touches[0].clientX, e.touches[0].clientY);
                    document.addEventListener('touchmove', onDocTouchMove, { passive: false });
                    document.addEventListener('touchend',  onDocTouchEnd,  { once: true });
                    document.addEventListener('touchcancel', onDocTouchEnd, { once: true });
                }, { passive: false });
            }
            function onDocMouseMove(e) { noteDragMove(e.clientX, e.clientY); }
            function onDocMouseUp()    { noteDragEnd(); document.removeEventListener('mousemove', onDocMouseMove); }
            function onDocTouchMove(e) { e.preventDefault(); if (e.touches.length===1) noteDragMove(e.touches[0].clientX, e.touches[0].clientY); }
            function onDocTouchEnd()   { noteDragEnd(); document.removeEventListener('touchmove', onDocTouchMove); }
            // makeDraggable ä¿ç•™ä¸ºç©ºæ“ä½œï¼ˆcreateNote ä»ä¼šè°ƒç”¨ï¼‰
            function makeDraggable(_el) { /* å·²æ”¹ä¸º wall å±‚äº‹ä»¶å§”æ‰˜ï¼Œæ— éœ€é€å…ƒç´ ç»‘å®š */ }

            // åˆå§‹åŒ–ä¾¿ç­¾ï¼ˆDocumentFragment æ‰¹é‡æ’å…¥ï¼Œåªè§¦å‘ä¸€æ¬¡ reflowï¼‰
            function initDefaultNotes(data = null) {
                if (!data || !data.notes) return;
                const frag = document.createDocumentFragment();
                data.notes.forEach((item) => {
                    frag.appendChild(createNote(
                        item.text,
                        null, null, null,
                        item.style  || 'yellow',
                        item.author || ''
                    ));
                });
                wall.appendChild(frag);
            }

            // è®¾å¤‡æ£€æµ‹
            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            const mobileDevice = isMobileDevice();
            
            // å­˜å‚¨å…‰æ ‡ä½ç½®
            let cursorPos = { x: 0, y: 0 };
            
            // æ›´æ–°å…‰æ ‡ä½ç½®ï¼ˆthrottleï¼šæ¯å¸§æœ€å¤šæ›´æ–°ä¸€æ¬¡ï¼‰
            let cursorRafPending = false;
            wrapper.addEventListener('mousemove', (e) => {
                if (cursorRafPending) return;
                cursorRafPending = true;
                requestAnimationFrame(() => {
                    cursorPos.x = e.clientX;
                    cursorPos.y = e.clientY;
                    cursorRafPending = false;
                });
            }, { passive: true });

            // ========== ç¼©æ”¾é€»è¾‘ (çº¯ transformï¼ŒGPU åŠ é€Ÿ) ==========
            let wallTranslateX = 0, wallTranslateY = 0;  // å¢™çš„å¹³ç§»é‡ï¼ˆpxï¼‰

            function updateZoom(newScale, useCursor = false) {
                const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                if (vw === 0 || vh === 0) return;
                const oldScale = currentScale;

                // ç¡®å®šç¼©æ”¾é”šç‚¹
                let focusX = vw / 2, focusY = vh / 2;
                if (useCursor && !mobileDevice) {
                    focusX = cursorPos.x;
                    focusY = cursorPos.y;
                }

                // ç¼©æ”¾æ—¶ä¿æŒé”šç‚¹ä¸åŠ¨ï¼š
                // é”šç‚¹åœ¨å¢™åæ ‡ç³»çš„ä½ç½® = (focusX - vw/2 - wallTranslateX) / oldScale
                // æ–°å¹³ç§»é‡ = wallTranslateX - (é”šç‚¹å¢™åæ ‡) * (newScale - oldScale)
                const anchorWallX = (focusX - vw/2 - wallTranslateX) / oldScale;
                const anchorWallY = (focusY - vh/2 - wallTranslateY) / oldScale;
                wallTranslateX -= anchorWallX * (newScale - oldScale);
                wallTranslateY -= anchorWallY * (newScale - oldScale);

                // é™åˆ¶å¹³ç§»èŒƒå›´ï¼Œç¡®ä¿å¢™ä¸ä¼šå®Œå…¨ç§»å‡ºè§†å£
                const scaledW = WALL_WIDTH * newScale, scaledH = WALL_HEIGHT * newScale;
                const maxOffsetX = Math.max(0, (scaledW - vw) / 2);
                const maxOffsetY = Math.max(0, (scaledH - vh) / 2);
                wallTranslateX = Math.max(-maxOffsetX, Math.min(maxOffsetX, wallTranslateX));
                wallTranslateY = Math.max(-maxOffsetY, Math.min(maxOffsetY, wallTranslateY));

                applyWallTransform(newScale);
                currentScale = newScale;
                zoomSpan.innerText = Math.round(newScale * 100) + '%';
            }

            function applyWallTransform(scale) {
                // translate(-50%, -50%) å±…ä¸­ + translate(offset) å¹³ç§» + scale(s) ç¼©æ”¾
                wall.style.transform = `translate(calc(-50% + ${wallTranslateX}px), calc(-50% + ${wallTranslateY}px)) scale(${scale})`;
            }

            // æ»‘å—äº‹ä»¶
            slider.addEventListener('input', (e) => {
                const newScale = parseFloat(e.target.value);
                updateZoom(newScale, !mobileDevice); // æ ¹æ®è®¾å¤‡ç±»å‹å†³å®šæ˜¯å¦ä½¿ç”¨å…‰æ ‡è·Ÿéšç¼©æ”¾
            });

            // é‡ç½®åˆ°å¢™é¢ä¸­å¿ƒ
            function scrollToCenter() {
                wallTranslateX = 0;
                wallTranslateY = 0;
                slider.value = currentScale;
                zoomSpan.innerText = Math.round(currentScale * 100) + '%';
                applyWallTransform(currentScale);
            }

            // åˆå§‹åŒ–ï¼šåŠ è½½ä¾¿ç­¾ â†’ æ¸²æŸ“ â†’ æ»šåŠ¨å®šä½
            window.addEventListener('DOMContentLoaded', () => {
                // æ‰‹åŠ¿å’Œå§”æ‰˜ç«‹å³ç»‘å®šï¼Œä¸ç­‰ fetch
                makeWallDraggable();
                initNoteDrag();
                // å…ˆå®šä½ï¼Œé¿å…åŠ è½½æ•°æ®æ—¶é¡µé¢ç©ºç™½
                scrollToCenter();
            });

            window.addEventListener('load', async () => {
                const loading = document.getElementById('loadingHint');
                if (loading) loading.style.display = 'block';
                try {
                    const response = await fetch(`notes-data.json?t=${Date.now()}`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    initDefaultNotes(data);
                } catch (error) {
                    console.warn('æ— æ³•åŠ è½½ä¾¿ç­¾æ•°æ®:', error.message);
                } finally {
                    if (loading) {
                        setTimeout(() => loading.style.display = 'none', 300);
                    }
                }
            });

            // â”€â”€ å¢™é¢æ‰‹åŠ¿ç®¡ç†å™¨ï¼šç»Ÿä¸€å¤„ç†å•æŒ‡æ‹–åŠ¨ + åŒæŒ‡ç¼©æ”¾ â”€â”€
            function makeWallDraggable() {

                // â”€â”€ é¼ æ ‡æ‹–åŠ¨ï¼ˆæ¡Œé¢ç«¯ï¼‰â”€â”€
                let mouseDown = false;
                let mouseStartX, mouseStartY, mouseInitTX, mouseInitTY;

                function onMouseDown(e) {
                    if (e.target === wall || e.target === wrapper) {
                        if (e.button !== 0) return;
                        e.preventDefault();
                        mouseDown = true;
                        mouseStartX = e.clientX;
                        mouseStartY = e.clientY;
                        mouseInitTX = wallTranslateX;
                        mouseInitTY = wallTranslateY;
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    }
                }
                function onMouseMove(e) {
                    if (!mouseDown) return;
                    const dx = e.clientX - mouseStartX;
                    const dy = e.clientY - mouseStartY;
                    wallTranslateX = mouseInitTX + dx;
                    wallTranslateY = mouseInitTY + dy;
                    // é™åˆ¶èŒƒå›´
                    const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                    const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                    const maxX = Math.max(0, (scaledW - vw) / 2);
                    const maxY = Math.max(0, (scaledH - vh) / 2);
                    wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                    wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));
                    applyWallTransform(currentScale);
                }
                function onMouseUp() {
                    mouseDown = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
                wall.addEventListener('mousedown', onMouseDown);
                wrapper.addEventListener('mousedown', onMouseDown);

                // â”€â”€ è§¦æ‘¸æ‰‹åŠ¿ï¼ˆç§»åŠ¨ç«¯ï¼‰ï¼šå•æŒ‡æ‹–åŠ¨ + åŒæŒ‡ pinch ç¼©æ”¾ â”€â”€
                let touchState = 'idle';
                let dragStartX, dragStartY, dragInitTX, dragInitTY;
                let pinchInitDist, pinchInitScale, pinchInitMidX, pinchInitMidY;
                let pinchInitTX, pinchInitTY;

                function getTouchMidpoint(touches) {
                    return {
                        x: (touches[0].clientX + touches[1].clientX) / 2,
                        y: (touches[0].clientY + touches[1].clientY) / 2,
                    };
                }
                function getTouchDist(touches) {
                    const dx = touches[1].clientX - touches[0].clientX;
                    const dy = touches[1].clientY - touches[0].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }

                function onTouchStart(e) {
                    // å¦‚æœè§¦æ‘¸èµ·ç‚¹åœ¨ zoom-control å†…ï¼Œå¿½ç•¥ï¼ˆè®©æ»‘å—è‡ªå·±å¤„ç†ï¼‰
                    if (e.target.closest && e.target.closest('.zoom-control')) return;

                    if (e.touches.length === 1) {
                        if (e.target === wall || e.target === wrapper) {
                            e.preventDefault();
                            touchState = 'drag';
                            dragStartX = e.touches[0].clientX;
                            dragStartY = e.touches[0].clientY;
                            dragInitTX = wallTranslateX;
                            dragInitTY = wallTranslateY;
                        }
                    } else if (e.touches.length === 2) {
                        e.preventDefault();
                        touchState = 'pinch';
                        pinchInitDist  = getTouchDist(e.touches);
                        pinchInitScale = currentScale;
                        const mid = getTouchMidpoint(e.touches);
                        pinchInitMidX = mid.x;
                        pinchInitMidY = mid.y;
                        pinchInitTX = wallTranslateX;
                        pinchInitTY = wallTranslateY;
                    }
                }

                function onTouchMove(e) {
                    if (touchState === 'idle') return;
                    e.preventDefault();

                    if (touchState === 'drag' && e.touches.length === 1) {
                        const dx = e.touches[0].clientX - dragStartX;
                        const dy = e.touches[0].clientY - dragStartY;
                        wallTranslateX = dragInitTX + dx;
                        wallTranslateY = dragInitTY + dy;
                        const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                        const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                        const maxX = Math.max(0, (scaledW - vw) / 2);
                        const maxY = Math.max(0, (scaledH - vh) / 2);
                        wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                        wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));
                        applyWallTransform(currentScale);

                    } else if (e.touches.length === 2) {
                        // å¦‚æœä¸­é€”å˜ä¸ºåŒæŒ‡ï¼Œå‡çº§ä¸º pinch
                        if (touchState !== 'pinch') {
                            touchState = 'pinch';
                            pinchInitDist  = getTouchDist(e.touches);
                            pinchInitScale = currentScale;
                            const mid = getTouchMidpoint(e.touches);
                            pinchInitMidX = mid.x;
                            pinchInitMidY = mid.y;
                            pinchInitTX = wallTranslateX;
                            pinchInitTY = wallTranslateY;
                            return;
                        }

                        const dist = getTouchDist(e.touches);
                        let newScale = pinchInitScale * (dist / pinchInitDist);
                        newScale = Math.max(0.2, Math.min(3, newScale));

                        // ä»¥åŒæŒ‡ä¸­ç‚¹ä¸ºé”šç‚¹ç¼©æ”¾
                        const mid = getTouchMidpoint(e.touches);
                        const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                        // é”šç‚¹åœ¨å¢™åæ ‡ç³»çš„ä½ç½®ï¼ˆç›¸å¯¹åˆå§‹æ—¶ï¼‰
                        const anchorWallX = (pinchInitMidX - vw/2 - pinchInitTX) / pinchInitScale;
                        const anchorWallY = (pinchInitMidY - vh/2 - pinchInitTY) / pinchInitScale;
                        // æ–°å¹³ç§» = åˆå§‹å¹³ç§» + é”šç‚¹åç§» + ä¸­ç‚¹ç§»åŠ¨
                        wallTranslateX = pinchInitTX - anchorWallX * (newScale - pinchInitScale) + (mid.x - pinchInitMidX);
                        wallTranslateY = pinchInitTY - anchorWallY * (newScale - pinchInitScale) + (mid.y - pinchInitMidY);

                        // é™åˆ¶èŒƒå›´
                        const scaledW = WALL_WIDTH * newScale, scaledH = WALL_HEIGHT * newScale;
                        const maxX = Math.max(0, (scaledW - vw) / 2);
                        const maxY = Math.max(0, (scaledH - vh) / 2);
                        wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                        wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));

                        applyWallTransform(newScale);
                        currentScale = newScale;
                        slider.value = newScale;
                        zoomSpan.innerText = Math.round(newScale * 100) + '%';
                    }
                }

                function onTouchEnd(e) {
                    if (e.touches.length === 0) {
                        touchState = 'idle';
                    } else if (e.touches.length === 1 && touchState === 'pinch') {
                        touchState = 'drag';
                        dragStartX = e.touches[0].clientX;
                        dragStartY = e.touches[0].clientY;
                        dragInitTX = wallTranslateX;
                        dragInitTY = wallTranslateY;
                    }
                }

                wrapper.addEventListener('touchstart', onTouchStart, { passive: false });
                wall.addEventListener('touchstart',    onTouchStart, { passive: false });
                // move/end æŒ‚åœ¨ documentï¼Œé¿å…æ‰‹æŒ‡åˆ’å‡º wrapper æ—¶ä¸¢å¤±äº‹ä»¶
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('touchend',  onTouchEnd,  { passive: true });
                document.addEventListener('touchcancel', onTouchEnd, { passive: true });
            }

            // zoom-control é˜»æ­¢è§¦æ‘¸äº‹ä»¶å†’æ³¡åˆ° wrapperï¼ˆé˜²æ­¢æ»‘å—æ“ä½œè§¦å‘å¢™é¢æ‹–åŠ¨ï¼‰
            document.querySelector('.zoom-control').addEventListener('touchstart', (e) => {
                e.stopPropagation();
            }, { passive: true });
            document.querySelector('.zoom-control').addEventListener('touchmove', (e) => {
                e.stopPropagation();
            }, { passive: true });

            // å¼¹çª—æ§åˆ¶
            const modal = document.getElementById('infoModal');
            const closeBtn = document.getElementById('closeModalBtn');
            closeBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
            });
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                }
            });

            // é¼ æ ‡æ»šè½®ç¼©æ”¾ï¼ˆpassive:false å…è®¸ preventDefaultï¼ŒrAF èŠ‚æµé¿å…è¿ç»­å¸§å †ç§¯ï¼‰
            let wheelRafId = null;
            wrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                cursorPos.x = e.clientX;
                cursorPos.y = e.clientY;
                const delta = e.deltaY > 0 ? -0.05 : 0.05;
                let newScale = Math.max(0.2, Math.min(3, currentScale + delta));
                slider.value = newScale;
                if (wheelRafId) return; // ä¸Šä¸€å¸§è¿˜æ²¡å¤„ç†å®Œï¼Œè·³è¿‡
                wheelRafId = requestAnimationFrame(() => {
                    updateZoom(newScale, !mobileDevice);
                    wheelRafId = null;
                });
            }, { passive: false });

            // åŒæŒ‡ç¼©æ”¾å·²æ•´åˆè‡³ makeWallDraggable() çš„ç»Ÿä¸€æ‰‹åŠ¿ç®¡ç†å™¨

            // çª—å£resizeæ—¶ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´æ»šåŠ¨è¾¹ç•Œ (ä¿æŒä¸­å¿ƒç‚¹ï¼Ÿä¸ºäº†ç®€åŒ–ï¼Œä¸åšé¢å¤–å¤„ç†ï¼Œä½†å¯ä¿æŒç¼©æ”¾ä¸å˜)
            // å¯é€‰ï¼šresize æ—¶é‡æ–°é™åˆ¶æ»šåŠ¨è¾¹ç•Œï¼Œä½†æ— éœ€æ›´æ”¹ç¼©æ”¾ã€‚
            window.addEventListener('resize', () => {
                // çª—å£å¤§å°å˜åŒ–æ—¶ï¼Œé™åˆ¶å¢™çš„å¹³ç§»èŒƒå›´
                const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                const maxX = Math.max(0, (scaledW - vw) / 2);
                const maxY = Math.max(0, (scaledH - vh) / 2);
                wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));
                applyWallTransform(currentScale);
            });
        })();
    </script>

    <!-- åŠ è½½æç¤º -->
    <div id="loadingHint" style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); 
         background:rgba(45,36,30,0.95); color:#f7d9a0; padding:20px 32px; border-radius:16px;
         font-family:'Segoe UI',sans-serif; font-size:1rem; z-index:30000; pointer-events:none;
         box-shadow:0 8px 32px rgba(0,0,0,0.6); display:none;">
        <div style="text-align:center;">
            <div style="font-size:2rem; margin-bottom:8px;">ğŸ§±</div>
            <div>åŠ è½½ä¾¿ç­¾ä¸­...</div>
        </div>
    </div>
</body>
</html>