<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>ä¾¿ç­¾æŠ•ç¨¿å¢™</title>
    <!-- æ€§èƒ½ä¼˜åŒ– -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="dns-prefetch" href="https://www.transparenttextures.com">
    <!-- ä½¿ç”¨ marked è§£æ Markdown (è½»é‡, å®‰å…¨) -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js" defer></script>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        body {
            background: #2d241e;
            font-family: 'Segoe UI', 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            touch-action: pan-x pan-y pinch-zoom; /* å…è®¸å•æŒ‡å¹³ç§» + åŒæŒ‡ç¼©æ”¾ */
        }

        /* å…¨å±å®¹å™¨ */
        .wall-wrapper {
            width: 100vw;
            height: 100vh;
            overflow: hidden;  /* å®Œå…¨ç¦ç”¨æ»šåŠ¨ï¼Œç”¨ transform æ§åˆ¶ */
            position: relative;
            touch-action: none;
            background: linear-gradient(to bottom, #87ceeb, #b0e0e6);
            cursor: grab;
        }
        .wall-wrapper:active {
            cursor: grabbing;
        }

        /* å·¨å¢™ â€” èƒŒæ™¯å›¾ç‰‡é“¾æ¥åœ¨æ­¤ä¿®æ”¹ */
        .wall {
            position: absolute;
            left: 50%; top: 50%;
            width: 10000px;
            height: 10000px;
            background-image: url('https://www.transparenttextures.com/patterns/old-wall.png');
            background-color: #b08a67;
            background-repeat: repeat;
            background-size: 300px 300px;
            box-shadow: inset 0 0 0 4px #5a3f2e;
            transform-origin: center center;  /* ä¸­å¿ƒç¼©æ”¾ï¼Œé…åˆ translate(-50%, -50%) */
            transform: translate(-50%, -50%) scale(1);
            will-change: transform;
            cursor: grab;
            backface-visibility: hidden;  /* å¼ºåˆ¶ GPU å±‚ */
            -webkit-backface-visibility: hidden;
        }
        .wall:active {
            cursor: grabbing;
        }
        


        /* ä¾¿ç­¾ç»Ÿä¸€æ ·å¼ â€” å°ºå¯¸å¯ä¿®æ”¹ */
        .note {
            position: absolute;
            width: 240px;
            min-height: 200px;
            background-color: #fffacd;
            border-bottom: 4px solid #d4b57e;
            border-right: 4px solid #c7a36b;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fffff0 inset;
            padding: 18px 16px 32px 20px;  /* bottom ç•™ç»™ç½²åè¡Œ */
            font-family: 'Segoe UI', 'Comic Sans MS', 'Marker Felt', cursive;
            font-size: 0.95rem;
            line-height: 1.5;
            color: #2d241b;
            border-radius: 5px 20px 12px 8px;
            transform-origin: 0 0;
            transition: left 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), top 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.25s ease-out, box-shadow 0.1s, filter 0.1s;
            cursor: grab;
            word-wrap: break-word;
            z-index: 1;
            will-change: transform;  /* æ”¹ä¸º transformï¼Œæ‹–åŠ¨ç”¨ translate */
            overflow: hidden;
            touch-action: none;
            contain: layout style;   /* éš”ç¦» reflow å½±å“ */
        }
        
        /* å¸¦å›¾ç‰‡èƒŒæ™¯çš„ä¾¿ç­¾ */
        .note.has-image-bg {
            background-color: #d6e8f5; /* å›¾ç‰‡åŠ è½½å‰/å¤±è´¥çš„é™çº§è‰² */
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
            position: relative;
        }
        /* å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶çš„æç¤º */
        .note.has-image-bg.img-error {
            background-color: #f0e8d8;
            background-image: none !important;
        }
        .note.has-image-bg.img-error::after {
            content: "ğŸ–¼ï¸";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            opacity: 0.3;
            pointer-events: none;
        }
        
        /* å›¾ç‰‡èƒŒæ™¯ä¾¿ç­¾çš„å†…å®¹è¦†ç›–å±‚ */
        .note.has-image-bg .note-content {
            background: rgba(255, 255, 255, 0.88);
            padding: 15px;
            border-radius: 4px;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }
        
        /* ä¾¿ç­¾æ ·å¼ - yellow */
        .note.style-yellow {
            background-color: #fffacd; /* å„ style-* / has-image-bg ç±»ä¼šè¦†ç›– */
            border-bottom: 4px solid #d4b57e;
            border-right: 4px solid #c7a36b;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fffff0 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - blue */
        .note.style-blue {
            background: #e6f7ff;
            background: linear-gradient(145deg, #f0f9ff, #d6f0ff);
            border-bottom: 4px solid #91d5ff;
            border-right: 4px solid #69c0ff;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f0f9ff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - green */
        .note.style-green {
            background: #f6ffed;
            background: linear-gradient(145deg, #f9fff2, #e8f5e8);
            border-bottom: 4px solid #b7eb8f;
            border-right: 4px solid #95de64;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f9fff2 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - pink */
        .note.style-pink {
            background: #fff0f6;
            background: linear-gradient(145deg, #fff5f8, #ffd6e7);
            border-bottom: 4px solid #ffadd2;
            border-right: 4px solid #ff85c0;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fff5f8 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - red */
        .note.style-red {
            background: #fff0f0;
            background: linear-gradient(145deg, #fff5f5, #ffd6d6);
            border-bottom: 4px solid #ff8585;
            border-right: 4px solid #ff5c5c;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fff5f5 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - purple */
        .note.style-purple {
            background: #f9f0ff;
            background: linear-gradient(145deg, #fcf5ff, #f0d6ff);
            border-bottom: 4px solid #d3adf7;
            border-right: 4px solid #b37feb;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fcf5ff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - orange */
        .note.style-orange {
            background: #fff7e6;
            background: linear-gradient(145deg, #fffbf0, #ffd6b3);
            border-bottom: 4px solid #ffc599;
            border-right: 4px solid #ffa94d;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fffbf0 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - teal */
        .note.style-teal {
            background: #e6fffb;
            background: linear-gradient(145deg, #f0fffb, #b3ffe6);
            border-bottom: 4px solid #85e6d9;
            border-right: 4px solid #5cdbd3;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f0fffb inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - indigo */
        .note.style-indigo {
            background: #f0f5ff;
            background: linear-gradient(145deg, #f5f9ff, #d6e4ff);
            border-bottom: 4px solid #adc6ff;
            border-right: 4px solid #86a8ff;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f5f9ff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - lime */
        .note.style-lime {
            background: #fafff0;
            background: linear-gradient(145deg, #fdfef9, #e8f5c8);
            border-bottom: 4px solid #e6ff70;
            border-right: 4px solid #d3f975;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fdfef9 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - cyan */
        .note.style-cyan {
            background: #e6ffff;
            background: linear-gradient(145deg, #f0ffff, #b3ffff);
            border-bottom: 4px solid #85ffff;
            border-right: 4px solid #5cdede;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f0ffff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - amber */
        .note.style-amber {
            background: #fffbe6;
            background: linear-gradient(145deg, #fefcf0, #ffefb3);
            border-bottom: 4px solid #ffd591;
            border-right: 4px solid #ffc14d;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fefcf0 inset;
        }
        
        /* è‡ªå®šä¹‰é¢œè‰²ä¾¿ç­¾ */
        .note.custom-color {
            border-bottom: 4px solid rgba(0,0,0,0.2);
            border-right: 4px solid rgba(0,0,0,0.3);
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 rgba(255,255,255,0.3) inset;
        }
        .note:hover {
            filter: brightness(1.02);
            box-shadow: 10px 10px 22px rgba(0,0,0,0.5), 0 0 0 2px #fceeb6;
            cursor: grab;
        }
        .note:active {
            cursor: grabbing;
            z-index: 9999 !important;
            box-shadow: 14px 14px 25px rgba(0,0,0,0.6);
        }
        /* å°æŠ˜è§’ */
        .note::before {
            content: "";
            position: absolute;
            top: 0;
            right: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 35px 35px 0;
            border-color: transparent #cfb07c transparent transparent;
            opacity: 0.6;
            pointer-events: none;
        }
        /* ä¾¿ç­¾å†…å®¹åŒºåŸŸ â€” æ¸²æŸ“ Markdown */
        .note-content {
            display: block;
            width: 100%;
            white-space: normal;
            word-break: break-word;
        }
        /* â”€â”€ è¿˜åŸè¢« * {margin:0;padding:0} æ¸…é›¶çš„ Markdown å…ƒç´ æ ·å¼ â”€â”€ */
        .note-content p {
            margin: 0 0 8px 0;
        }
        .note-content h1, .note-content h2, .note-content h3,
        .note-content h4, .note-content h5, .note-content h6 {
            font-weight: bold;
            margin: 6px 0 4px 0;
            line-height: 1.3;
        }
        .note-content h1 { font-size: 1.3em; }
        .note-content h2 { font-size: 1.15em; }
        .note-content h3 { font-size: 1.05em; }
        .note-content strong, .note-content b { font-weight: bold; }
        .note-content em, .note-content i { font-style: italic; }
        .note-content s, .note-content del { text-decoration: line-through; }
        .note-content ul, .note-content ol {
            margin: 4px 0 4px 18px;
            padding: 0;
        }
        .note-content ul { list-style: disc; }
        .note-content ol { list-style: decimal; }
        .note-content li { margin: 2px 0; }
        .note-content blockquote {
            border-left: 3px solid #c9a86c;
            margin: 6px 0 6px 4px;
            padding: 2px 0 2px 10px;
            color: #6b4f2a;
            font-style: italic;
        }
        .note-content code {
            background: rgba(0,0,0,0.08);
            padding: 1px 5px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.88em;
        }
        .note-content pre {
            background: rgba(0,0,0,0.08);
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 6px 0;
        }
        .note-content pre code {
            background: none;
            padding: 0;
        }
        .note-content hr {
            border: none;
            border-top: 1px dashed #c9a86c;
            margin: 8px 0;
        }
        .note-content a {
            color: #a55808;
            text-decoration: underline;
            cursor: pointer;
        }


        /* ä¾¿ç­¾ç½²å â€” ç»å¯¹å®šä½å›ºå®šäºå³ä¸‹è§’ */
        .note-author {
            position: absolute;
            bottom: 8px;
            right: 12px;
            left: 20px;         /* å·¦è¾¹ç•Œï¼Œé˜²æ­¢é•¿åå­—æº¢å‡º */
            font-size: 0.72rem;
            color: rgba(60,40,20,0.55);
            text-align: right;
            font-style: italic;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            pointer-events: none;
            border-top: 1px dashed rgba(0,0,0,0.12);
            padding-top: 4px;
            line-height: 1.3;
        }

        /* ç¼©æ”¾æ§åˆ¶æ¡ â€” å³ä¸‹è§’å›ºå®šï¼Œç§»åŠ¨ç«¯å‹å¥½ */
        .zoom-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(45, 36, 30, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 12px 20px;
            border-radius: 40px;
            border: 2px solid #bb9d7b;
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 20000;
            color: #f7e3c2;
            box-shadow: 0 10px 25px rgba(0,0,0,0.6);
            font-size: 1rem;
            touch-action: manipulation;
        }
        .zoom-control label {
            font-size: 1.3rem;
            font-weight: bold;
            line-height: 1;
        }
        .zoom-control input {
            width: 200px;
            height: 10px;
            background: #4f3e2e;
            border-radius: 20px;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            touch-action: manipulation;
        }
        .zoom-control input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 28px;
            height: 28px;
            background: #f7d9a0;
            border-radius: 50%;
            border: 2px solid #7b5b3e;
            box-shadow: 0 2px 8px black;
            cursor: grab;
            touch-action: manipulation;
        }
        .zoom-control input::-moz-range-thumb {
            width: 28px;
            height: 28px;
            background: #f7d9a0;
            border-radius: 50%;
            border: 2px solid #7b5b3e;
            cursor: grab;
            touch-action: manipulation;
        }
        .zoom-control span {
            min-width: 65px;
            font-size: 1.3rem;
            background: #2d1f14;
            padding: 5px 12px;
            border-radius: 40px;
            text-align: center;
            border: 1px solid #c8a87c;
        }

        /* ä¿¡æ¯å¼¹çª— */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(45,36,30,0.88);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300000;
            padding: 15px;
        }
        .modal-box {
            background: #fef7e9;
            max-width: 500px;
            width: 100%;
            padding: 25px 20px;
            border-radius: 40px 15px 40px 15px;
            box-shadow: 0 30px 40px rgba(0,0,0,0.6), 0 10px 0 #bc9f7e inset;
            text-align: left;
            border: 5px solid #dac29c;
            font-size: 1rem;
            color: #3f2e1f;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-box h2 {
            margin: 0 0 15px 0;
            font-weight: 400;
            color: #4a3322;
            font-size: 2rem;
            border-bottom: 2px dashed #b48c65;
            padding-bottom: 8px;
        }
        .modal-box ul {
            margin: 15px 0;
            padding-left: 25px;
        }
        .modal-box li {
            margin: 8px 0;
        }
        .modal-box code {
            background: #2d241e;
            color: #fadfad;
            padding: 2px 8px;
            border-radius: 30px;
            font-family: monospace;
            font-size: 0.85rem;
        }
        .modal-close {
            background: #b48c65;
            border: none;
            border-bottom: 5px solid #7b5b3e;
            padding: 12px 30px;
            border-radius: 40px;
            font-size: 1.3rem;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.1s;
            margin-top: 15px;
            display: block;
            margin-left: auto;
            touch-action: manipulation;
        }
        .modal-close:active {
            transform: translateY(4px);
            border-bottom-width: 2px;
        }
        .hidden {
            display: none;
        }

        /* ç§»åŠ¨ç«¯è°ƒæ•´æ»‘å—å®½åº¦ */
        @media (max-width: 600px) {
            .zoom-control {
                padding: 10px 15px;
                gap: 10px;
                bottom: 15px;
                right: 15px;
            }
            .zoom-control input {
                width: 130px;
            }
            .zoom-control span {
                min-width: 55px;
                font-size: 1.1rem;
            }
            .zoom-control label {
                font-size: 1.1rem;
            }
        }
    
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            .note {
                font-size: 1rem;        /* å­—å·ç¨å¤§ï¼Œè§¦æ‘¸å‹å¥½ */
                min-height: 180px;
            }
            .zoom-control {
                bottom: 16px;
                right: 16px;
                padding: 10px 16px;
                font-size: 0.9rem;
            }
            .zoom-control input {
                width: 140px;
            }
        }
</style>
</head>
<body>
    <!-- æ»šåŠ¨å®¹å™¨ -->
    <div class="wall-wrapper" id="wallWrapper">
        <!-- å·¨å¢™ (10000x10000) -->
        <div class="wall" id="wall"></div>
    </div>

    <!-- ç¼©æ”¾æ»‘å— (å³ä¸‹è§’) -->
    <div class="zoom-control">
        <label>ğŸ”</label>
        <input type="range" id="zoomSlider" min="0.2" max="3" step="0.02" value="1">
        <span id="zoomPercent">100%</span>
    </div>

    <!-- å¼¹çª— (ä½¿ç”¨è¯´æ˜) -->
    <div class="modal-overlay" id="infoModal" style="display:none;">
        <div class="modal-box">
            <h2>ğŸ§± ä¾¿ç­¾æŠ•ç¨¿å¢™</h2>
            <p style="margin:12px 0;color:#9e8870;">æ‹–åŠ¨å¢™é¢æ¢ç´¢ Â· ç¼©æ”¾æŸ¥çœ‹ Â· ç‚¹å‡»ä¾¿ç­¾å¯æ‹–åŠ¨</p>
            <ul>
                <li><strong>ç¼©æ”¾</strong>ï¼šæ»šè½® / åŒæŒ‡æåˆ / å³ä¸‹è§’æ»‘å—</li>
                <li><strong>æ‹–åŠ¨</strong>ï¼šé¼ æ ‡/å•æŒ‡æ‹–åŠ¨ç©ºç™½åŒºåŸŸæˆ–ä¾¿ç­¾</li>
                <li><strong>æŠ•ç¨¿</strong>ï¼šç¼–è¾‘ notes-data.json æ·»åŠ ä¾¿ç­¾</li>
            </ul>
            <button class="modal-close" id="closeModalBtn">å¼€å§‹æ¢ç´¢ ğŸš€</button>
        </div>
    </div>

    <script>
        (function() {
            // å¢™é¢å¤§å°é…ç½® - å¯ä»¥è½»æ¾ä¿®æ”¹è¿™é‡Œæ¥æ”¹å˜å¢™é¢å°ºå¯¸
            const WALL_WIDTH = 10000;
            const WALL_HEIGHT = 10000;

            const wall = document.getElementById('wall');
            const wrapper = document.getElementById('wallWrapper');
            const slider = document.getElementById('zoomSlider');
            const zoomSpan = document.getElementById('zoomPercent');

            // è®¾ç½®å¢™é¢å¤§å°
            wall.style.width = WALL_WIDTH + 'px';
            wall.style.height = WALL_HEIGHT + 'px';

            let maxZIndex = 1000;
            let currentScale = 1.0; // å½“å‰ç¼©æ”¾å€¼

            // å·¥å…·å‡½æ•°ï¼šéšæœºèŒƒå›´
            const random = (min, max) => Math.random() * (max - min) + min;

            // â”€â”€ å¯è§å­—ç¬¦è®¡æ•°ï¼šå‰¥ç¦»æ‰€æœ‰ Markdown è¯­æ³•ç¬¦å·å’Œ URLï¼Œåªæ•°å®é™…å†…å®¹ â”€â”€
            const MAX_CHARS = 100;
            function countVisible(text) {
                if (!text) return 0;
                return text
                    .replace(/!?\[([^\]]*?)\]\([^)]*?\)/g, '$1') // é“¾æ¥/å›¾ç‰‡ï¼šåªä¿ç•™æ˜¾ç¤ºæ–‡å­—
                    .replace(/```[\s\S]*?```/g, m => m.slice(3, -3).trim()) // ä»£ç å—
                    .replace(/`([^`]*?)`/g, '$1')   // è¡Œå†…ä»£ç 
                    .replace(/^#{1,6}\s+/gm, '')     // æ ‡é¢˜ç¬¦å·
                    .replace(/[*_~]{1,3}/g, '')      // ç²—ä½“/æ–œä½“/åˆ é™¤çº¿ç¬¦å·
                    .replace(/^>\s*/gm, '')           // å¼•ç”¨ç¬¦å·
                    .replace(/^[-*+]\s+/gm, '')       // æ— åºåˆ—è¡¨ç¬¦å·
                    .replace(/^\d+\.\s+/gm, '')       // æœ‰åºåˆ—è¡¨ç¬¦å·
                    .replace(/^[-*_]{3,}\s*$/gm, '')  // æ°´å¹³çº¿
                    .replace(/\n/g, '')               // æ¢è¡Œä¸è®¡å­—æ•°
                    .length;
            }

            function truncateText(text) {
                if (!text) return '';
                if (countVisible(text) <= MAX_CHARS) return text;
                // é€æ­¥æ‰«æåŸæ–‡ï¼Œè·³è¿‡ä¸è®¡å­—æ•°çš„éƒ¨åˆ†ï¼Œè¾¾åˆ°ä¸Šé™æ—¶æˆªæ–­
                let visible = 0;
                let i = 0;
                while (i < text.length && visible < MAX_CHARS) {
                    const rest = text.slice(i);
                    let m;
                    // é“¾æ¥/å›¾ç‰‡ [æ˜¾ç¤ºæ–‡å­—](url) â†’ åªè®¡æ˜¾ç¤ºæ–‡å­—
                    if ((m = rest.match(/^!?\[([^\]]*?)\]\([^)]*?\)/))) {
                        visible += m[1].length; i += m[0].length; continue;
                    }
                    // ä»£ç å— ```...```
                    if ((m = rest.match(/^```[\s\S]*?```/))) {
                        visible += m[0].slice(3,-3).trim().replace(/\n/g,'').length;
                        i += m[0].length; continue;
                    }
                    // è¡Œå†…ä»£ç  `...`
                    if ((m = rest.match(/^`([^`]*?)`/))) {
                        visible += m[1].length; i += m[0].length; continue;
                    }
                    // æ ‡é¢˜ç¬¦å· # ## ...ï¼ˆè¡Œé¦–ï¼‰
                    if ((m = rest.match(/^#{1,6}\s+/))) { i += m[0].length; continue; }
                    // ç²—ä½“/æ–œä½“/åˆ é™¤çº¿ç¬¦å·
                    if ((m = rest.match(/^[*_~]{1,3}/))) { i += m[0].length; continue; }
                    // å¼•ç”¨ç¬¦å· > ï¼ˆè¡Œé¦–ï¼‰
                    if ((m = rest.match(/^>\s*/))) { i += m[0].length; continue; }
                    // åˆ—è¡¨ç¬¦å·ï¼ˆè¡Œé¦–ï¼‰
                    if ((m = rest.match(/^[-*+]\s+|^\d+\.\s+/))) { i += m[0].length; continue; }
                    // æ°´å¹³çº¿
                    if ((m = rest.match(/^[-*_]{3,}\s*\n/))) { i += m[0].length; continue; }
                    // æ¢è¡Œä¸è®¡
                    if (text[i] === '\n') { i++; continue; }
                    visible++;
                    i++;
                }
                return text.slice(0, i) + 'â€¦';
            }

            // Markdown æ¸²æŸ“ï¼ˆå¸¦ç¼“å­˜ï¼‰
            function renderMarkdown(text) {
                if (typeof marked === 'undefined') return text;
                if (!mdCache.has(text)) {
                    try { mdCache.set(text, marked.parse(text)); } catch(e) { mdCache.set(text, text); }
                }
                return mdCache.get(text);
            }

            // marked å°±ç»ªåé‡æ–°æ¸²æŸ“ï¼ˆå¸¦ç¼“å­˜ï¼Œé¿å…é‡å¤è§£æï¼‰
            const mdCache = new Map();
            function rewireMarkdown() {
                if (typeof marked === 'undefined') return;
                document.querySelectorAll('.note-content[data-raw]').forEach(el => {
                    const raw = el.dataset.raw;
                    if (!mdCache.has(raw)) {
                        try { mdCache.set(raw, marked.parse(raw)); } catch(e) { mdCache.set(raw, raw); }
                    }
                    el.innerHTML = mdCache.get(raw);
                    delete el.dataset.raw;
                });
            }
            document.querySelector('script[src*="marked"]')
                ?.addEventListener('load', rewireMarkdown);



            // â”€â”€ è™šæ‹Ÿæ»šåŠ¨ç®¡ç†å™¨ï¼šå¤§é‡ä¾¿ç­¾æ—¶åªæ¸²æŸ“å¯è§åŒºåŸŸ â”€â”€
            const BUFFER = 500;  // è§†å£å¤–æ‰© 500px ç¼“å†²åŒº
            let allNotesData = [];  // æ‰€æœ‰ä¾¿ç­¾çš„åŸå§‹æ•°æ®
            let renderedNotes = new Map();  // noteId â†’ DOM element
            let viewportCheckTimer = null;

            function addNoteData(text, style, author) {
                const id = `note-${allNotesData.length}`;
                // é¢„åˆ†é…ä½ç½®ï¼ˆéšæœºæˆ–ç½‘æ ¼ï¼Œè¿™é‡Œç”¨éšæœºï¼‰
                const left = Math.random() * (WALL_WIDTH - 240) + 50;
                const top  = Math.random() * (WALL_HEIGHT - 200) + 50;
                const rotate = Math.random() * 10 - 5;
                allNotesData.push({ id, text, style, author, left, top, rotate });
                return id;
            }

            function isInViewport(noteData) {
                const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                const scale = currentScale || 1;
                // wall ä¸­å¿ƒåœ¨è§†å£ä¸­å¿ƒï¼Œtranslate æ˜¯åç§»é‡
                const viewCenterX = WALL_WIDTH / 2 - wallTranslateX / scale;
                const viewCenterY = WALL_HEIGHT / 2 - wallTranslateY / scale;
                // è§†å£åœ¨å¢™åæ ‡ç³»çš„èŒƒå›´
                const viewX = viewCenterX - vw / (2 * scale);
                const viewY = viewCenterY - vh / (2 * scale);
                const viewW = vw / scale;
                const viewH = vh / scale;
                // ä¾¿ç­¾åŒ…å›´ç›’ï¼ˆå« bufferï¼‰
                const noteX = noteData.left - BUFFER;
                const noteY = noteData.top  - BUFFER;
                const noteW = 240 + BUFFER * 2;
                const noteH = 200 + BUFFER * 2;
                // AABB ç¢°æ’æ£€æµ‹
                return !(noteX + noteW < viewX || noteX > viewX + viewW ||
                         noteY + noteH < viewY || noteY > viewY + viewH);
            }

            function updateVisibleNotes() {
                const toRender = new Set();
                const toRemove = [];

                // æ£€æŸ¥å“ªäº›ä¾¿ç­¾åº”è¯¥æ˜¾ç¤º
                allNotesData.forEach(data => {
                    if (isInViewport(data)) {
                        toRender.add(data.id);
                        if (!renderedNotes.has(data.id)) {
                            renderNote(data);
                        }
                    }
                });

                // ç§»é™¤ä¸å¯è§çš„ä¾¿ç­¾ï¼ˆé‡Šæ”¾ DOMï¼‰
                renderedNotes.forEach((el, id) => {
                    if (!toRender.has(id)) {
                        toRemove.push(id);
                    }
                });

                toRemove.forEach(id => {
                    const el = renderedNotes.get(id);
                    if (el) {
                        // æ¸…ç† Intersection Observerï¼ˆå¦‚æœæœ‰ï¼‰
                        if (imgObserver && el.dataset.bgImg) {
                            imgObserver.unobserve(el);
                        }
                        // ç§»é™¤ DOM
                        if (el.parentNode) el.parentNode.removeChild(el);
                    }
                    renderedNotes.delete(id);
                });
            }

            function renderNote(data) {
                const note = createNote(data.text, data.left, data.top, data.rotate, data.style, data.author);
                note.dataset.noteId = data.id;
                wall.appendChild(note);
                renderedNotes.set(data.id, note);
            }

            // ç¼©æ”¾/æ‹–åŠ¨åå»¶è¿Ÿè§¦å‘ï¼ˆ300ms debounceï¼Œé¿å…é¢‘ç¹åˆ‡æ¢ï¼‰
            function scheduleViewportCheck() {
                if (viewportCheckTimer) clearTimeout(viewportCheckTimer);
                viewportCheckTimer = setTimeout(updateVisibleNotes, 300);
            }

            // â”€â”€ å›¾ç‰‡èƒŒæ™¯æ‡’åŠ è½½ï¼ˆIntersection Observerï¼‰â”€â”€
            let imgObserver = null;
            function initImgObserver() {
                if (imgObserver) return;
                imgObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const note = entry.target;
                            const imgUrl = note.dataset.bgImg;
                            if (imgUrl) {
                                const img = new Image();
                                img.onload = () => {
                                    note.style.setProperty('background-image', `url("${imgUrl}")`, 'important');
                                    delete note.dataset.bgImg;
                                };
                                img.onerror = () => note.classList.add('img-error');
                                img.src = imgUrl;
                                imgObserver.unobserve(note);
                            }
                        }
                    });
                }, { 
                    root: wrapper,  // é™å®šåœ¨ wrapper å†…æ£€æµ‹
                    rootMargin: '200px',  // æå‰ 200px
                    threshold: 0.01  // åªè¦éœ²å‡º 1% å°±è§¦å‘
                });
            }

            // åˆ›å»ºä¾¿ç­¾ï¼ˆæ”¯æŒ styleï¼šé¢œè‰²å / #hex / å›¾ç‰‡é“¾æ¥ï¼Œä»¥åŠå¯é€‰ author ç½²åï¼‰
            function createNote(mdText, left, top, rotate = null, style = 'yellow', author = '') {
                const note = document.createElement('div');
                note.className = 'note';

                // â”€â”€ èƒŒæ™¯æ ·å¼ â”€â”€
                if (typeof style === 'string') {
                    if (style.startsWith('http') || style.startsWith('//')) {
                        note.classList.add('has-image-bg');
                        note.dataset.bgImg = style;  // å­˜åˆ° data å±æ€§ï¼Œå»¶è¿ŸåŠ è½½
                        initImgObserver();
                        imgObserver.observe(note);  // è¿›å…¥è§†å£åæ‰åŠ è½½
                    } else if (style.startsWith('#')) {
                        note.classList.add('custom-color');
                        note.style.background = `linear-gradient(145deg, ${lightenColor(style, 5)}, ${darkenColor(style, 5)})`;
                    } else {
                        note.classList.add(`style-${style}`);
                    }
                } else {
                    note.classList.add('style-yellow');
                }

                // â”€â”€ æ—‹è½¬ & ä½ç½® â”€â”€
                const rot = (rotate !== null) ? rotate : random(-5, 6);
                note.style.transform = `rotate(${rot}deg)`;
                const noteLeft = left !== null ? left : random(200, WALL_WIDTH - 200);
                const noteTop  = top  !== null ? top  : random(200, WALL_HEIGHT - 200);
                note.style.left = noteLeft + 'px';
                note.style.top  = noteTop  + 'px';
                // ç¡®ä¿ä¾¿ç­¾æœ‰æ˜ç¡®å®šä½ï¼Œé˜²æ­¢æ‹–åŠ¨æ—¶åæ ‡é”™ä¹±
                note.style.position = 'absolute';
                note.style.zIndex = Math.floor(random(10, 500));

                // â”€â”€ æ­£æ–‡å†…å®¹ â”€â”€
                const contentSpan = document.createElement('span');
                contentSpan.className = 'note-content';
                const truncated = truncateText(mdText);
                const html = renderMarkdown(truncated);
                contentSpan.innerHTML = html;
                // è‹¥ marked å°šæœªå°±ç»ªï¼ˆdeferï¼‰ï¼Œä¿å­˜åŸæ–‡ä¾› rewireMarkdown è¡¥æ¸²æŸ“
                if (html === truncated && truncated.trim()) {
                    contentSpan.dataset.raw = truncated;
                }
                note.appendChild(contentSpan);

                // â”€â”€ ç½²åï¼ˆæœ‰ author æ—¶æ˜¾ç¤ºï¼‰â”€â”€
                if (author && author.trim()) {
                    const authorEl = document.createElement('span');
                    authorEl.className = 'note-author';
                    authorEl.textContent = 'â€” ' + author.trim();
                    note.appendChild(authorEl);
                }

                makeDraggable(note);
                return note;
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šè°ƒæ•´é¢œè‰²äº®åº¦
            function lightenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
            }
            
            function darkenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R>255?255:R<0?0:R)*0x10000 + (G>255?255:G<0?0:G)*0x100 + (B>255?255:B<0?0:B)).toString(16).slice(1);
            }

            // â”€â”€ ä¾¿ç­¾æ‹–æ‹½ï¼šäº‹ä»¶å§”æ‰˜åˆ° wallï¼Œé¿å… N å¼ ä¾¿ç­¾ Ã— 2 ä¸ªç›‘å¬å™¨ â”€â”€
            // æ‹–æ‹½çŠ¶æ€ï¼ˆå…¨å±€å•ä¾‹ï¼ŒåŒæ—¶åªèƒ½æ‹–ä¸€å¼ ï¼‰
            let dragNote = null, dragStartX = 0, dragStartY = 0;
            let dragInitLeft = 0, dragInitTop = 0;
            let dragHasMoved = false;
            let dragVX = 0, dragVY = 0, dragLastX = 0, dragLastY = 0, dragLastT = 0;
            let dragRafId = null;
            // é¢„å­˜ä¾¿ç­¾å°ºå¯¸ï¼Œé¿å…æ‹–åŠ¨ä¸­åå¤è§¦å‘ layout
            const NOTE_W = 240, NOTE_H = 200;

            function noteDragStart(note, clientX, clientY) {
                dragNote = note;
                dragStartX = clientX; dragStartY = clientY;
                // æ¸…é™¤ä¹‹å‰å¯èƒ½æ®‹ç•™çš„ translate
                note.style.transform = '';
                dragInitLeft  = parseFloat(note.style.left)  || 0;
                dragInitTop   = parseFloat(note.style.top)   || 0;
                dragLastX = clientX; dragLastY = clientY;
                dragLastT = Date.now();
                dragVX = 0; dragVY = 0;
                dragHasMoved = false;
                maxZIndex++;
                note.style.zIndex = maxZIndex;
                note.style.transition = 'none';
            }

            function noteDragMove(clientX, clientY) {
                if (!dragNote) return;
                const now = Date.now(), dt = now - dragLastT;
                if (dt > 0) {
                    dragVX = (clientX - dragLastX) / dt * 16;
                    dragVY = (clientY - dragLastY) / dt * 16;
                }
                dragLastX = clientX; dragLastY = clientY; dragLastT = now;

                const dx = clientX - dragStartX, dy = clientY - dragStartY;
                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragHasMoved = true;

                // è®¡ç®—æœ€ç»ˆä½ç½®ï¼ˆå¸¦è¾¹ç•Œé™åˆ¶ï¼‰
                let newLeft = Math.min(WALL_WIDTH - 30,  Math.max(-NOTE_W + 30, dragInitLeft + dx));
                let newTop  = Math.min(WALL_HEIGHT - 30, Math.max(-NOTE_H + 30, dragInitTop  + dy));

                // rAF èŠ‚æµï¼šæ‹–æ‹½ä¸­ç”¨ translate ç›¸å¯¹åç§»ï¼ˆç›¸å¯¹äºåŸå§‹ left/topï¼‰
                if (dragRafId) cancelAnimationFrame(dragRafId);
                dragRafId = requestAnimationFrame(() => {
                    if (dragNote) {
                        dragNote.style.transition = 'none';
                        // translate ç”¨ç›¸å¯¹åç§»é‡ï¼Œè€Œéç»å¯¹ä½ç½®
                        const offsetX = newLeft - dragInitLeft;
                        const offsetY = newTop - dragInitTop;
                        dragNote.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                    }
                });
            }

            function noteDragEnd() {
                if (!dragNote) return;
                cancelAnimationFrame(dragRafId);
                const note = dragNote;
                dragNote = null;
                dragRafId = null;
                
                if (!dragHasMoved) {
                    // æœªç§»åŠ¨ï¼Œç›´æ¥æ¢å¤
                    note.style.transform = '';
                    note.style.transition = '';
                    return;
                }

                // è¯»å–å½“å‰ translate åç§»é‡
                let offsetX = 0, offsetY = 0;
                const m = note.style.transform.match(/translate\(([^,]+)px,\s*([^)]+)px\)/);
                if (m) {
                    offsetX = parseFloat(m[1]);
                    offsetY = parseFloat(m[2]);
                }

                // å½“å‰ç»å¯¹ä½ç½® = åˆå§‹ä½ç½® + translate åç§»
                let curX = dragInitLeft + offsetX;
                let curY = dragInitTop + offsetY;

                // åº”ç”¨é€Ÿåº¦è¡°å‡ï¼ˆç²˜æ»æ•ˆæœï¼‰
                // é€Ÿåº¦è¡°å‡ç³»æ•° 0.6ï¼ˆå€¼è¶Šå¤§æƒ¯æ€§è¶Šå¼ºï¼Œ0-1ï¼‰
                let finalX = curX + dragVX * 0.6;
                let finalY = curY + dragVY * 0.6;

                // è¾¹ç•Œé™åˆ¶
                finalX = Math.min(WALL_WIDTH - 30, Math.max(-NOTE_W + 30, finalX));
                finalY = Math.min(WALL_HEIGHT - 30, Math.max(-NOTE_H + 30, finalY));

                // å†™å› left/topï¼Œæ¸…é™¤ translateï¼Œå¯ç”¨ transition åšå¹³æ»‘è¿‡æ¸¡
                note.style.left = finalX + 'px';
                note.style.top  = finalY + 'px';
                note.style.transform = '';
                // æ˜¾å¼å¯ç”¨ transition å®ç°ç²˜æ»æ•ˆæœ
                note.style.transition = 'left 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), top 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                // 0.3s åæ¸…é™¤ transitionï¼Œé¿å…åç»­æ“ä½œå¸¦åŠ¨ç”»
                setTimeout(() => { note.style.transition = ''; }, 320);
            }

            // wall å±‚ç»Ÿä¸€å§”æ‰˜ mousedown / touchstart
            function initNoteDrag() {
                wall.addEventListener('mousedown', (e) => {
                    const note = e.target.closest('.note');
                    if (!note || e.button !== 0) return;
                    if (e.target.closest('a')) return; // è¶…é“¾æ¥ä¸æ‹–
                    e.preventDefault(); e.stopPropagation();
                    noteDragStart(note, e.clientX, e.clientY);
                    document.addEventListener('mousemove', onDocMouseMove);
                    document.addEventListener('mouseup',  onDocMouseUp,  { once: true });
                });
                wall.addEventListener('touchstart', (e) => {
                    if (e.touches.length !== 1) return;
                    const note = e.target.closest('.note');
                    if (!note) return;
                    if (e.target.closest('a')) return;
                    e.preventDefault(); e.stopPropagation();
                    noteDragStart(note, e.touches[0].clientX, e.touches[0].clientY);
                    document.addEventListener('touchmove', onDocTouchMove, { passive: false });
                    document.addEventListener('touchend',  onDocTouchEnd,  { once: true });
                    document.addEventListener('touchcancel', onDocTouchEnd, { once: true });
                }, { passive: false });
            }
            function onDocMouseMove(e) { noteDragMove(e.clientX, e.clientY); }
            function onDocMouseUp()    { noteDragEnd(); document.removeEventListener('mousemove', onDocMouseMove); }
            function onDocTouchMove(e) { e.preventDefault(); if (e.touches.length===1) noteDragMove(e.touches[0].clientX, e.touches[0].clientY); }
            function onDocTouchEnd()   { noteDragEnd(); document.removeEventListener('touchmove', onDocTouchMove); }
            function makeDraggable(_el) { /* äº‹ä»¶å§”æ‰˜ï¼Œæ— éœ€é€å…ƒç´ ç»‘å®š */ }

            // â”€â”€ zoom-control å½»åº•éš”ç¦»æ‰€æœ‰è§¦æ‘¸/é¼ æ ‡äº‹ä»¶ â”€â”€
            function isolateZoomControl() {
                const zoomCtrl = document.querySelector('.zoom-control');
                if (!zoomCtrl) return;
                
                ['mousedown','touchstart','touchmove','touchend','click'].forEach(evt => {
                    zoomCtrl.addEventListener(evt, (e) => {
                        e.stopPropagation();  // é˜»æ­¢å†’æ³¡åˆ° wall/wrapper
                    }, { passive: evt !== 'touchstart' && evt !== 'touchmove' });
                });
            }

            // åˆå§‹åŒ–ä¾¿ç­¾ï¼ˆå°‘é‡ç›´æ¥æ¸²æŸ“ï¼Œå¤§é‡åˆ†æ‰¹+è™šæ‹Ÿæ»šåŠ¨ï¼‰
            function initDefaultNotes(data = null) {
                if (!data || !data.notes) return;
                
                const noteCount = data.notes.length;
                
                // å°‘é‡ä¾¿ç­¾ï¼ˆâ‰¤50ï¼‰ï¼šç›´æ¥å…¨éƒ¨æ¸²æŸ“ï¼Œä¸å¯ç”¨è™šæ‹Ÿæ»šåŠ¨
                if (noteCount <= 50) {
                    const frag = document.createDocumentFragment();
                    data.notes.forEach((item) => {
                        const note = createNote(
                            item.text,
                            null, null, null,
                            item.style  || 'yellow',
                            item.author || ''
                        );
                        frag.appendChild(note);
                    });
                    wall.appendChild(frag);
                    console.log(`âœ“ å·²æ¸²æŸ“ ${noteCount} å¼ ä¾¿ç­¾ï¼ˆç›´æ¥æ¨¡å¼ï¼‰`);
                    return;
                }
                
                // å¤§é‡ä¾¿ç­¾ï¼ˆ>50ï¼‰ï¼šå¯ç”¨è™šæ‹Ÿæ»šåŠ¨
                allNotesData = [];
                data.notes.forEach((item) => {
                    addNoteData(
                        item.text,
                        item.style  || 'yellow',
                        item.author || ''
                    );
                });
                renderInBatches();
            }

            function renderInBatches() {
                const BATCH_SIZE = 20;  // æ¯æ‰¹ 20 ä¸ª
                let index = 0;
                
                function renderBatch(deadline) {
                    // åœ¨ç©ºé—²æ—¶é—´æ¸²æŸ“ï¼Œæ¯æ‰¹æœ€å¤š 50ms
                    const endTime = deadline ? deadline.timeRemaining() : 50;
                    const startTime = performance.now();

                    while (index < allNotesData.length && 
                           (performance.now() - startTime) < endTime) {
                        const data = allNotesData[index];
                        if (isInViewport(data)) {
                            renderNote(data);
                        }
                        index++;
                    }

                    // æ›´æ–°è¿›åº¦
                    const loadingText = document.getElementById('loadingText');
                    if (loadingText) {
                        const pct = Math.round((index / allNotesData.length) * 100);
                        loadingText.textContent = `æ­£åœ¨æ¸²æŸ“ä¾¿ç­¾... ${index}/${allNotesData.length} (${pct}%)`;
                    }

                    if (index < allNotesData.length) {
                        if (typeof requestIdleCallback !== 'undefined') {
                            requestIdleCallback(renderBatch);
                        } else {
                            setTimeout(() => renderBatch(null), 16);
                        }
                    } else {
                        console.log(`âœ“ å·²æ¸²æŸ“ ${renderedNotes.size}/${allNotesData.length} å¼ ä¾¿ç­¾`);
                        const loading = document.getElementById('loadingHint');
                        if (loading) setTimeout(() => loading.style.display = 'none', 300);
                    }
                }

                // å¯åŠ¨åˆ†æ‰¹æ¸²æŸ“
                if (typeof requestIdleCallback !== 'undefined') {
                    requestIdleCallback(renderBatch);
                } else {
                    setTimeout(() => renderBatch(null), 0);
                }
            }

            // è®¾å¤‡æ£€æµ‹
            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            const mobileDevice = isMobileDevice();
            
            // å­˜å‚¨å…‰æ ‡ä½ç½®
            let cursorPos = { x: 0, y: 0 };
            
            // æ›´æ–°å…‰æ ‡ä½ç½®ï¼ˆthrottleï¼šæ¯å¸§æœ€å¤šæ›´æ–°ä¸€æ¬¡ï¼‰
            let cursorRafPending = false;
            wrapper.addEventListener('mousemove', (e) => {
                if (cursorRafPending) return;
                cursorRafPending = true;
                requestAnimationFrame(() => {
                    cursorPos.x = e.clientX;
                    cursorPos.y = e.clientY;
                    cursorRafPending = false;
                });
            }, { passive: true });

            // ========== ç¼©æ”¾é€»è¾‘ (çº¯ transformï¼ŒGPU åŠ é€Ÿ) ==========
            let wallTranslateX = 0, wallTranslateY = 0;  // å¢™çš„å¹³ç§»é‡ï¼ˆpxï¼‰

            function updateZoom(newScale, useCursor = false) {
                const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                if (vw === 0 || vh === 0) return;
                const oldScale = currentScale;

                // ç¡®å®šç¼©æ”¾é”šç‚¹
                let focusX = vw / 2, focusY = vh / 2;
                if (useCursor && !mobileDevice) {
                    focusX = cursorPos.x;
                    focusY = cursorPos.y;
                }

                // ç¼©æ”¾æ—¶ä¿æŒé”šç‚¹ä¸åŠ¨ï¼š
                // é”šç‚¹åœ¨å¢™åæ ‡ç³»çš„ä½ç½® = (focusX - vw/2 - wallTranslateX) / oldScale
                // æ–°å¹³ç§»é‡ = wallTranslateX - (é”šç‚¹å¢™åæ ‡) * (newScale - oldScale)
                const anchorWallX = (focusX - vw/2 - wallTranslateX) / oldScale;
                const anchorWallY = (focusY - vh/2 - wallTranslateY) / oldScale;
                wallTranslateX -= anchorWallX * (newScale - oldScale);
                wallTranslateY -= anchorWallY * (newScale - oldScale);

                // é™åˆ¶å¹³ç§»èŒƒå›´ï¼Œç¡®ä¿å¢™ä¸ä¼šå®Œå…¨ç§»å‡ºè§†å£
                const scaledW = WALL_WIDTH * newScale, scaledH = WALL_HEIGHT * newScale;
                const maxOffsetX = Math.max(0, (scaledW - vw) / 2);
                const maxOffsetY = Math.max(0, (scaledH - vh) / 2);
                wallTranslateX = Math.max(-maxOffsetX, Math.min(maxOffsetX, wallTranslateX));
                wallTranslateY = Math.max(-maxOffsetY, Math.min(maxOffsetY, wallTranslateY));

                applyWallTransform(newScale);
                currentScale = newScale;
                zoomSpan.innerText = Math.round(newScale * 100) + '%';
            }

            function applyWallTransform(scale) {
                wall.style.transform = `translate(calc(-50% + ${wallTranslateX}px), calc(-50% + ${wallTranslateY}px)) scale(${scale})`;
                // åªåœ¨è™šæ‹Ÿæ»šåŠ¨å¯ç”¨ä¸”æœ‰æ•°æ®æ—¶è§¦å‘
                if (allNotesData && allNotesData.length > 50) scheduleViewportCheck();
            }

            // æ»‘å—äº‹ä»¶
            slider.addEventListener('input', (e) => {
                const newScale = parseFloat(e.target.value);
                updateZoom(newScale, !mobileDevice); // æ ¹æ®è®¾å¤‡ç±»å‹å†³å®šæ˜¯å¦ä½¿ç”¨å…‰æ ‡è·Ÿéšç¼©æ”¾
            });

            // é‡ç½®åˆ°å¢™é¢ä¸­å¿ƒ
            function scrollToCenter() {
                wallTranslateX = 0;
                wallTranslateY = 0;
                slider.value = currentScale;
                zoomSpan.innerText = Math.round(currentScale * 100) + '%';
                applyWallTransform(currentScale);
            }

            // åˆå§‹åŒ–ï¼šåŠ è½½ä¾¿ç­¾ â†’ æ¸²æŸ“ â†’ æ»šåŠ¨å®šä½
            window.addEventListener('DOMContentLoaded', () => {
                console.log('ğŸ§± ä¾¿ç­¾å¢™åˆå§‹åŒ–...');
                makeWallDraggable();
                initNoteDrag();
                isolateZoomControl();
                scrollToCenter();
                console.log('âœ“ å¢™é¢å°±ç»ª');

            // â”€â”€ FPS ç›‘æ§ï¼ˆå¯é€‰ï¼‰â”€â”€
            if (document.getElementById('fpsCounter')) {
                document.getElementById('fpsCounter').style.display = 'block';
                let lastTime = performance.now();
                let frames = 0;
                function updateFPS() {
                    frames++;
                    const now = performance.now();
                    if (now - lastTime >= 1000) {
                        const fps = Math.round(frames * 1000 / (now - lastTime));
                        document.getElementById('fpsValue').textContent = fps;
                        document.getElementById('noteCount').textContent = renderedNotes.size;
                        frames = 0;
                        lastTime = now;
                    }
                    requestAnimationFrame(updateFPS);
                }
                updateFPS();
            }


            });

            window.addEventListener('load', async () => {
                const loading = document.getElementById('loadingHint');
                const loadingText = document.getElementById('loadingText');
                if (loading) loading.style.display = 'block';
                if (loadingText) loadingText.textContent = 'åŠ è½½ä¾¿ç­¾æ•°æ®...';
                
                try {
                    const response = await fetch(`notes-data.json?t=${Date.now()}`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    
                    const noteCount = data.notes?.length || 0;
                    if (loadingText) {
                        loadingText.textContent = `å·²åŠ è½½ ${noteCount} å¼ ä¾¿ç­¾`;
                    }
                    
                    initDefaultNotes(data);
                    
                    // å°‘é‡ä¾¿ç­¾ï¼ˆâ‰¤50ï¼‰ç«‹å³å…³é—­ loading
                    if (noteCount <= 50) {
                        setTimeout(() => {
                            if (loading) loading.style.display = 'none';
                        }, 200);
                    }
                    // å¤§é‡ä¾¿ç­¾ç”± renderInBatches å…³é—­
                } catch (error) {
                    console.warn('åŠ è½½ä¾¿ç­¾æ•°æ®å¤±è´¥:', error.message);
                    if (loadingText) loadingText.textContent = 'âš ï¸ åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ notes-data.json';
                    setTimeout(() => {
                        if (loading) loading.style.display = 'none';
                    }, 2000);
                }
            });

            // â”€â”€ å¢™é¢æ‰‹åŠ¿ç®¡ç†å™¨ï¼šç»Ÿä¸€å¤„ç†å•æŒ‡æ‹–åŠ¨ + åŒæŒ‡ç¼©æ”¾ â”€â”€
            function makeWallDraggable() {

                // â”€â”€ é¼ æ ‡æ‹–åŠ¨ï¼ˆæ¡Œé¢ç«¯ï¼‰â”€â”€
                let mouseDown = false;
                let mouseStartX, mouseStartY, mouseInitTX, mouseInitTY;

                function onMouseDown(e) {
                    if (e.target === wall || e.target === wrapper) {
                        if (e.button !== 0) return;
                        e.preventDefault();
                        mouseDown = true;
                        mouseStartX = e.clientX;
                        mouseStartY = e.clientY;
                        mouseInitTX = wallTranslateX;
                        mouseInitTY = wallTranslateY;
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    }
                }
                function onMouseMove(e) {
                    if (!mouseDown) return;
                    const dx = e.clientX - mouseStartX;
                    const dy = e.clientY - mouseStartY;
                    wallTranslateX = mouseInitTX + dx;
                    wallTranslateY = mouseInitTY + dy;
                    // é™åˆ¶èŒƒå›´
                    const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                    const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                    const maxX = Math.max(0, (scaledW - vw) / 2);
                    const maxY = Math.max(0, (scaledH - vh) / 2);
                    wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                    wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));
                    applyWallTransform(currentScale);
                }
                function onMouseUp() {
                    mouseDown = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
                wall.addEventListener('mousedown', onMouseDown);
                wrapper.addEventListener('mousedown', onMouseDown);

                // â”€â”€ è§¦æ‘¸æ‰‹åŠ¿ï¼ˆç§»åŠ¨ç«¯ï¼‰ï¼šå•æŒ‡æ‹–åŠ¨ + åŒæŒ‡ pinch ç¼©æ”¾ â”€â”€
                let touchState = 'idle';
                let dragStartX, dragStartY, dragInitTX, dragInitTY;
                let pinchInitDist, pinchInitScale, pinchInitMidX, pinchInitMidY;
                let pinchInitTX, pinchInitTY;

                function getTouchMidpoint(touches) {
                    return {
                        x: (touches[0].clientX + touches[1].clientX) / 2,
                        y: (touches[0].clientY + touches[1].clientY) / 2,
                    };
                }
                function getTouchDist(touches) {
                    const dx = touches[1].clientX - touches[0].clientX;
                    const dy = touches[1].clientY - touches[0].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }

                function onTouchStart(e) {
                    // å¦‚æœè§¦æ‘¸èµ·ç‚¹åœ¨ zoom-control å†…ï¼Œå¿½ç•¥ï¼ˆè®©æ»‘å—è‡ªå·±å¤„ç†ï¼‰
                    if (e.target.closest && e.target.closest('.zoom-control')) return;

                    if (e.touches.length === 1) {
                        if (e.target === wall || e.target === wrapper) {
                            e.preventDefault();
                            touchState = 'drag';
                            dragStartX = e.touches[0].clientX;
                            dragStartY = e.touches[0].clientY;
                            dragInitTX = wallTranslateX;
                            dragInitTY = wallTranslateY;
                        }
                    } else if (e.touches.length === 2) {
                        e.preventDefault();
                        touchState = 'pinch';
                        pinchInitDist  = getTouchDist(e.touches);
                        pinchInitScale = currentScale;
                        const mid = getTouchMidpoint(e.touches);
                        pinchInitMidX = mid.x;
                        pinchInitMidY = mid.y;
                        pinchInitTX = wallTranslateX;
                        pinchInitTY = wallTranslateY;
                    }
                }

                function onTouchMove(e) {
                    if (touchState === 'idle') return;
                    e.preventDefault();

                    if (touchState === 'drag' && e.touches.length === 1) {
                        const dx = e.touches[0].clientX - dragStartX;
                        const dy = e.touches[0].clientY - dragStartY;
                        wallTranslateX = dragInitTX + dx;
                        wallTranslateY = dragInitTY + dy;
                        const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                        const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                        const maxX = Math.max(0, (scaledW - vw) / 2);
                        const maxY = Math.max(0, (scaledH - vh) / 2);
                        wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                        wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));
                        applyWallTransform(currentScale);

                    } else if (e.touches.length === 2) {
                        // å¦‚æœä¸­é€”å˜ä¸ºåŒæŒ‡ï¼Œå‡çº§ä¸º pinch
                        if (touchState !== 'pinch') {
                            touchState = 'pinch';
                            pinchInitDist  = getTouchDist(e.touches);
                            pinchInitScale = currentScale;
                            const mid = getTouchMidpoint(e.touches);
                            pinchInitMidX = mid.x;
                            pinchInitMidY = mid.y;
                            pinchInitTX = wallTranslateX;
                            pinchInitTY = wallTranslateY;
                            return;
                        }

                        const dist = getTouchDist(e.touches);
                        let newScale = pinchInitScale * (dist / pinchInitDist);
                        newScale = Math.max(0.2, Math.min(3, newScale));

                        // ä»¥åŒæŒ‡ä¸­ç‚¹ä¸ºé”šç‚¹ç¼©æ”¾
                        const mid = getTouchMidpoint(e.touches);
                        const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                        // é”šç‚¹åœ¨å¢™åæ ‡ç³»çš„ä½ç½®ï¼ˆç›¸å¯¹åˆå§‹æ—¶ï¼‰
                        const anchorWallX = (pinchInitMidX - vw/2 - pinchInitTX) / pinchInitScale;
                        const anchorWallY = (pinchInitMidY - vh/2 - pinchInitTY) / pinchInitScale;
                        // æ–°å¹³ç§» = åˆå§‹å¹³ç§» + é”šç‚¹åç§» + ä¸­ç‚¹ç§»åŠ¨
                        wallTranslateX = pinchInitTX - anchorWallX * (newScale - pinchInitScale) + (mid.x - pinchInitMidX);
                        wallTranslateY = pinchInitTY - anchorWallY * (newScale - pinchInitScale) + (mid.y - pinchInitMidY);

                        // é™åˆ¶èŒƒå›´
                        const scaledW = WALL_WIDTH * newScale, scaledH = WALL_HEIGHT * newScale;
                        const maxX = Math.max(0, (scaledW - vw) / 2);
                        const maxY = Math.max(0, (scaledH - vh) / 2);
                        wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                        wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));

                        applyWallTransform(newScale);
                        currentScale = newScale;
                        slider.value = newScale;
                        zoomSpan.innerText = Math.round(newScale * 100) + '%';
                    }
                }

                function onTouchEnd(e) {
                    if (e.touches.length === 0) {
                        touchState = 'idle';
                    } else if (e.touches.length === 1 && touchState === 'pinch') {
                        touchState = 'drag';
                        dragStartX = e.touches[0].clientX;
                        dragStartY = e.touches[0].clientY;
                        dragInitTX = wallTranslateX;
                        dragInitTY = wallTranslateY;
                    }
                }

                wrapper.addEventListener('touchstart', onTouchStart, { passive: false });
                wall.addEventListener('touchstart',    onTouchStart, { passive: false });
                // move/end æŒ‚åœ¨ documentï¼Œé¿å…æ‰‹æŒ‡åˆ’å‡º wrapper æ—¶ä¸¢å¤±äº‹ä»¶
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('touchend',  onTouchEnd,  { passive: true });
                document.addEventListener('touchcancel', onTouchEnd, { passive: true });
            }

            // zoom-control é˜»æ­¢è§¦æ‘¸äº‹ä»¶å†’æ³¡åˆ° wrapperï¼ˆé˜²æ­¢æ»‘å—æ“ä½œè§¦å‘å¢™é¢æ‹–åŠ¨ï¼‰
            document.querySelector('.zoom-control').addEventListener('touchstart', (e) => {
                e.stopPropagation();
            }, { passive: true });
            document.querySelector('.zoom-control').addEventListener('touchmove', (e) => {
                e.stopPropagation();
            }, { passive: true });

            // å¼¹çª—æ§åˆ¶
            const modal = document.getElementById('infoModal');
            const closeBtn = document.getElementById('closeModalBtn');
            closeBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
            });
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                }
            });

            // é¼ æ ‡æ»šè½®ç¼©æ”¾ï¼ˆpassive:false å…è®¸ preventDefaultï¼ŒrAF èŠ‚æµé¿å…è¿ç»­å¸§å †ç§¯ï¼‰
            let wheelRafId = null;
            wrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                cursorPos.x = e.clientX;
                cursorPos.y = e.clientY;
                const delta = e.deltaY > 0 ? -0.05 : 0.05;
                let newScale = Math.max(0.2, Math.min(3, currentScale + delta));
                slider.value = newScale;
                if (wheelRafId) return; // ä¸Šä¸€å¸§è¿˜æ²¡å¤„ç†å®Œï¼Œè·³è¿‡
                wheelRafId = requestAnimationFrame(() => {
                    updateZoom(newScale, !mobileDevice);
                    wheelRafId = null;
                });
            }, { passive: false });

            // åŒæŒ‡ç¼©æ”¾å·²æ•´åˆè‡³ makeWallDraggable() çš„ç»Ÿä¸€æ‰‹åŠ¿ç®¡ç†å™¨

            // çª—å£resizeæ—¶ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´æ»šåŠ¨è¾¹ç•Œ (ä¿æŒä¸­å¿ƒç‚¹ï¼Ÿä¸ºäº†ç®€åŒ–ï¼Œä¸åšé¢å¤–å¤„ç†ï¼Œä½†å¯ä¿æŒç¼©æ”¾ä¸å˜)
            // å¯é€‰ï¼šresize æ—¶é‡æ–°é™åˆ¶æ»šåŠ¨è¾¹ç•Œï¼Œä½†æ— éœ€æ›´æ”¹ç¼©æ”¾ã€‚
            window.addEventListener('resize', () => {
                // çª—å£å¤§å°å˜åŒ–æ—¶ï¼Œé™åˆ¶å¢™çš„å¹³ç§»èŒƒå›´
                const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                const maxX = Math.max(0, (scaledW - vw) / 2);
                const maxY = Math.max(0, (scaledH - vh) / 2);
                wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));
                applyWallTransform(currentScale);
                if (allNotesData.length > 50) scheduleViewportCheck();
            });
        })();
    </script>


    <!-- FPS ç›‘æ§ï¼ˆå¯é€‰ï¼Œæ­£å¼ç¯å¢ƒå¯åˆ é™¤ï¼‰ -->
    <div id="fpsCounter" style="position:fixed; top:10px; left:10px; background:rgba(0,0,0,0.7); 
         color:#7ec87e; padding:6px 12px; border-radius:6px; font-family:monospace; 
         font-size:12px; z-index:30000; pointer-events:none; display:none;">
        FPS: <span id="fpsValue">60</span> | ä¾¿ç­¾: <span id="noteCount">0</span>
    </div>
    <!-- åŠ è½½æç¤º -->
    <div id="loadingHint" style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); 
         background:rgba(45,36,30,0.95); color:#f7d9a0; padding:20px 32px; border-radius:16px;
         font-family:'Segoe UI',sans-serif; font-size:1rem; z-index:30000; pointer-events:none;
         box-shadow:0 8px 32px rgba(0,0,0,0.6); display:none;">
        <div style="text-align:center;">
            <div style="font-size:2rem; margin-bottom:8px;">ğŸ§±</div>
            <div id="loadingText">åŠ è½½ä¾¿ç­¾ä¸­...</div>
        </div>
    </div>
</body>
</html>