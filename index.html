<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>ä¾¿ç­¾æŠ•ç¨¿å¢™</title>
    <!-- æ€§èƒ½ä¼˜åŒ– -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="dns-prefetch" href="https://www.transparenttextures.com">
    <!-- ä½¿ç”¨ marked è§£æ Markdown (è½»é‡, å®‰å…¨) -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js" defer></script>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        body {
            background: #2d241e;
            font-family: 'Segoe UI', 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            touch-action: pan-x pan-y pinch-zoom; /* å…è®¸å•æŒ‡å¹³ç§» + åŒæŒ‡ç¼©æ”¾ */
        }

        /* å…¨å±å®¹å™¨ */
        .wall-wrapper {
            width: 100vw;
            height: 100vh;
            overflow: hidden;  /* å®Œå…¨ç¦ç”¨æ»šåŠ¨ï¼Œç”¨ transform æ§åˆ¶ */
            position: relative;
            touch-action: none;
            background: #9dd1e0;  /* å•è‰²èƒŒæ™¯ï¼Œé¿å…æ¸å˜é‡ç»˜ */
            cursor: grab;
        }
        .wall-wrapper:active {
            cursor: grabbing;
        }

        /* å·¨å¢™ â€” èƒŒæ™¯å›¾ç‰‡é“¾æ¥åœ¨æ­¤ä¿®æ”¹ */
        .wall {
            position: absolute;
            left: 50%; top: 50%;
            width: 10000px;
            height: 10000px;
            background-image: url('https://www.transparenttextures.com/patterns/old-wall.png');
            background-color: #b08a67;
            background-repeat: repeat;
            background-size: 300px 300px;
            background-attachment: local;  /* é¿å…èƒŒæ™¯å›¾éšæ»šåŠ¨é‡ç»˜ */
            box-shadow: inset 0 0 0 4px #5a3f2e;
            transform-origin: center center;
            transform: translate3d(-50%, -50%, 0) scale(1);  /* translate3d è§¦å‘ GPU */
            /* will-change ç§»é™¤ï¼Œå‡å°‘é—ªçƒ */
            cursor: grab;
            backface-visibility: hidden;  /* å¼ºåˆ¶ GPU å±‚ */
            -webkit-backface-visibility: hidden;
        }
        .wall:active {
            cursor: grabbing;
        }
        


        /* ä¾¿ç­¾ç»Ÿä¸€æ ·å¼ â€” å°ºå¯¸å¯ä¿®æ”¹ */
        .note {
            position: absolute;
            width: 240px;
            min-height: 200px;
            background-color: #fffacd;
            border-bottom: 4px solid #d4b57e;
            border-right: 4px solid #c7a36b;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fffff0 inset;
            padding: 18px 16px 32px 20px;  /* bottom ç•™ç»™ç½²åè¡Œ */
            font-family: 'Segoe UI', 'Comic Sans MS', 'Marker Felt', cursive;
            font-size: 0.95rem;
            line-height: 1.5;
            color: #2d241b;
            border-radius: 5px 20px 12px 8px;
            transform-origin: 0 0;
            transition: box-shadow 0.1s, filter 0.1s;  /* ç§»é™¤ left/top transitionï¼Œé¿å…æ‹–åŠ¨å¡é¡¿ */
            cursor: grab;
            word-wrap: break-word;
            z-index: 1;
            /* will-change ç§»é™¤ */  /* æ”¹ä¸º transformï¼Œæ‹–åŠ¨ç”¨ translate */
            overflow: hidden;
            touch-action: none;
            contain: layout style;  /* éš”ç¦»å¸ƒå±€å’Œæ ·å¼ */
        }
        
        /* å¸¦å›¾ç‰‡èƒŒæ™¯çš„ä¾¿ç­¾ */
        .note.has-image-bg {
            background-color: #d6e8f5; /* å›¾ç‰‡åŠ è½½å‰/å¤±è´¥çš„é™çº§è‰² */
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
            position: relative;
        }

        /* å›¾ç‰‡èƒŒæ™¯åŠ è½½çŠ¶æ€ */
        .note.has-image-bg:not(.img-loaded):not(.img-error) {
            background-color: #d6e8f5;
            background-image: none !important;
        }
        .note.has-image-bg:not(.img-loaded):not(.img-error)::before {
            content: "â³";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            opacity: 0.3;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.4; }
        }
        /* å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶çš„æç¤º */
        .note.has-image-bg.img-error {
            background-color: #f0e8d8;
            background-image: none !important;
        }
        .note.has-image-bg.img-error::after {
            content: "ğŸ–¼ï¸";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            opacity: 0.3;
            pointer-events: none;
        }
        
        /* å›¾ç‰‡èƒŒæ™¯ä¾¿ç­¾çš„å†…å®¹è¦†ç›–å±‚ï¼ˆåŠé€æ˜ï¼Œå¯è§èƒŒæ™¯å›¾ï¼‰ */
        .note.has-image-bg .note-content {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.72) 0%, 
                rgba(255, 255, 255, 0.62) 50%,
                rgba(255, 255, 255, 0.72) 100%);
            padding: 15px;
            border-radius: 4px;
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        /* ä¾¿ç­¾æ ·å¼ - yellow */
        .note.style-yellow {
            background-color: #fffacd; /* å„ style-* / has-image-bg ç±»ä¼šè¦†ç›– */
            border-bottom: 4px solid #d4b57e;
            border-right: 4px solid #c7a36b;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fffff0 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - blue */
        .note.style-blue {
            background: #e6f7ff;
            background: linear-gradient(145deg, #f0f9ff, #d6f0ff);
            border-bottom: 4px solid #91d5ff;
            border-right: 4px solid #69c0ff;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f0f9ff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - green */
        .note.style-green {
            background: #f6ffed;
            background: linear-gradient(145deg, #f9fff2, #e8f5e8);
            border-bottom: 4px solid #b7eb8f;
            border-right: 4px solid #95de64;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f9fff2 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - pink */
        .note.style-pink {
            background: #fff0f6;
            background: linear-gradient(145deg, #fff5f8, #ffd6e7);
            border-bottom: 4px solid #ffadd2;
            border-right: 4px solid #ff85c0;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fff5f8 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - red */
        .note.style-red {
            background: #fff0f0;
            background: linear-gradient(145deg, #fff5f5, #ffd6d6);
            border-bottom: 4px solid #ff8585;
            border-right: 4px solid #ff5c5c;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fff5f5 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - purple */
        .note.style-purple {
            background: #f9f0ff;
            background: linear-gradient(145deg, #fcf5ff, #f0d6ff);
            border-bottom: 4px solid #d3adf7;
            border-right: 4px solid #b37feb;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fcf5ff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - orange */
        .note.style-orange {
            background: #fff7e6;
            background: linear-gradient(145deg, #fffbf0, #ffd6b3);
            border-bottom: 4px solid #ffc599;
            border-right: 4px solid #ffa94d;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fffbf0 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - teal */
        .note.style-teal {
            background: #e6fffb;
            background: linear-gradient(145deg, #f0fffb, #b3ffe6);
            border-bottom: 4px solid #85e6d9;
            border-right: 4px solid #5cdbd3;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f0fffb inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - indigo */
        .note.style-indigo {
            background: #f0f5ff;
            background: linear-gradient(145deg, #f5f9ff, #d6e4ff);
            border-bottom: 4px solid #adc6ff;
            border-right: 4px solid #86a8ff;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f5f9ff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - lime */
        .note.style-lime {
            background: #fafff0;
            background: linear-gradient(145deg, #fdfef9, #e8f5c8);
            border-bottom: 4px solid #e6ff70;
            border-right: 4px solid #d3f975;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fdfef9 inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - cyan */
        .note.style-cyan {
            background: #e6ffff;
            background: linear-gradient(145deg, #f0ffff, #b3ffff);
            border-bottom: 4px solid #85ffff;
            border-right: 4px solid #5cdede;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #f0ffff inset;
        }
        
        /* ä¾¿ç­¾æ ·å¼ - amber */
        .note.style-amber {
            background: #fffbe6;
            background: linear-gradient(145deg, #fefcf0, #ffefb3);
            border-bottom: 4px solid #ffd591;
            border-right: 4px solid #ffc14d;
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 #fefcf0 inset;
        }
        
        /* è‡ªå®šä¹‰é¢œè‰²ä¾¿ç­¾ */
        .note.custom-color {
            border-bottom: 4px solid rgba(0,0,0,0.2);
            border-right: 4px solid rgba(0,0,0,0.3);
            box-shadow: 6px 6px 15px rgba(0,0,0,0.4), 0 2px 0 rgba(255,255,255,0.3) inset;
        }
        .note:hover {
            filter: brightness(1.02);
            box-shadow: 10px 10px 22px rgba(0,0,0,0.5), 0 0 0 2px #fceeb6;
            cursor: grab;
        }
        .note:active {
            cursor: grabbing;
            z-index: 9999 !important;
            box-shadow: 14px 14px 25px rgba(0,0,0,0.6);
        }
        /* å°æŠ˜è§’ */
        .note::before {
            content: "";
            position: absolute;
            top: 0;
            right: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 35px 35px 0;
            border-color: transparent #cfb07c transparent transparent;
            opacity: 0.6;
            pointer-events: none;
        }
        /* ä¾¿ç­¾å†…å®¹åŒºåŸŸ â€” æ¸²æŸ“ Markdown */
        .note-content {
            display: block;
            width: 100%;
            white-space: normal;
            word-break: break-word;
        }
        /* â”€â”€ è¿˜åŸè¢« * {margin:0;padding:0} æ¸…é›¶çš„ Markdown å…ƒç´ æ ·å¼ â”€â”€ */
        .note-content p {
            margin: 0 0 8px 0;
        }
        .note-content h1, .note-content h2, .note-content h3,
        .note-content h4, .note-content h5, .note-content h6 {
            font-weight: bold;
            margin: 6px 0 4px 0;
            line-height: 1.3;
        }
        .note-content h1 { font-size: 1.3em; }
        .note-content h2 { font-size: 1.15em; }
        .note-content h3 { font-size: 1.05em; }
        .note-content strong, .note-content b { font-weight: bold; }
        .note-content em, .note-content i { font-style: italic; }
        .note-content s, .note-content del { text-decoration: line-through; }
        .note-content ul, .note-content ol {
            margin: 4px 0 4px 18px;
            padding: 0;
        }
        .note-content ul { list-style: disc; }
        .note-content ol { list-style: decimal; }
        .note-content li { margin: 2px 0; }
        .note-content blockquote {
            border-left: 3px solid #c9a86c;
            margin: 6px 0 6px 4px;
            padding: 2px 0 2px 10px;
            color: #6b4f2a;
            font-style: italic;
        }
        .note-content code {
            background: rgba(0,0,0,0.08);
            padding: 1px 5px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.88em;
        }
        .note-content pre {
            background: rgba(0,0,0,0.08);
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 6px 0;
        }
        .note-content pre code {
            background: none;
            padding: 0;
        }
        .note-content hr {
            border: none;
            border-top: 1px dashed #c9a86c;
            margin: 8px 0;
        }
        .note-content a {
            color: #a55808;
            text-decoration: underline;
            cursor: pointer;
        }


        /* ä¾¿ç­¾ç½²å â€” ç»å¯¹å®šä½å›ºå®šäºå³ä¸‹è§’ */
        .note-author {
            position: absolute;
            bottom: 8px;
            right: 12px;
            left: 20px;
            font-size: 0.72rem;
            color: rgba(60,40,20,0.55);
            text-align: right;
            font-style: italic;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            pointer-events: none;
            border-top: 1px dashed rgba(0,0,0,0.12);
            padding-top: 4px;
            line-height: 1.3;
        }
        /* å›¾ç‰‡èƒŒæ™¯ä¾¿ç­¾çš„ç½²ååŠ åŠé€æ˜èƒŒæ™¯ */
        .note.has-image-bg .note-author {
            background: rgba(255,255,255,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            border-top: none;
            left: auto;
            width: auto;
        }

        /* å¯¼èˆªå›¾æ ‡ */
        .nav-icon {
            position: fixed;
            width: 44px;
            height: 44px;
            background: rgba(255,250,240,0.95);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            transition: all 0.2s;
            z-index: 25000;
            border: 2px solid #d4b57e;
        }
        .nav-icon:hover {
            transform: scale(1.05) translateZ(0);  /* GPU åŠ é€Ÿ */
            background: #fff;
        }
        .nav-icon svg {
            width: 22px;
            height: 22px;
            fill: #8b6f47;
        }
        .home-icon { top: 16px; left: 16px; }
        .search-icon { top: 16px; right: 70px; }
        .help-icon { top: 16px; right: 16px; }

        /* æœç´¢é¢æ¿ */
        .search-panel {
            position: fixed;
            top: 70px;
            right: 16px;
            transform: translateZ(0);  /* ç‹¬ç«‹åˆæˆå±‚ */
            width: 320px;
            max-height: 400px;
            background: rgba(254,247,233,0.98);
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            padding: 16px;
            z-index: 30000;  /* æé«˜å±‚çº§ï¼Œé¿å…è¢«é®æŒ¡ */
            display: none;
            border: 2px solid #d4b57e;
        }
        .search-panel input {
            width: 100%;
            padding: 10px 12px;
            border: 1.5px solid #c9a86c;
            border-radius: 8px;
            font-size: 0.9rem;
            outline: none;
            background: #fff;
        }
        .search-results {
            margin-top: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .search-result-item {
            padding: 8px 10px;
            margin: 4px 0;
            background: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            border: 1px solid #e8d5b7;
            transition: all 0.15s;
        }
        .search-result-item:hover {
            background: #f5e9d3;
            border-color: #c9a86c;
        }
        .search-result-item .result-text {
            color: #5a4a38;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .search-result-item .result-author {
            font-size: 0.75rem;
            color: #9e8870;
            margin-top: 4px;
        }
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            .note {
                font-size: 1rem;
                min-height: 180px;
            }
            .nav-icon {
                width: 48px;
                height: 48px;
            }
            .nav-icon svg {
                width: 24px;
                height: 24px;
            }
            .search-panel {
                width: calc(100vw - 32px);
                right: 16px;
            }
        }
</style>
</head>
<body>
    <!-- æ»šåŠ¨å®¹å™¨ -->
    <div class="wall-wrapper" id="wallWrapper">
        <!-- å·¨å¢™ (10000x10000) -->
        <div class="wall" id="wall"></div>
    </div>

    <!-- ç¼©æ”¾æ»‘å— (å³ä¸‹è§’) -->

    <!-- å¼¹çª— (ä½¿ç”¨è¯´æ˜) -->
    <div class="modal-overlay" id="infoModal" style="display:none;opacity:0;">
        <div class="modal-box">
            <h2>ğŸ§± ä¾¿ç­¾æŠ•ç¨¿å¢™</h2>
            <p style="margin:12px 0;color:#9e8870;font-size:0.95rem;">
                è¿™æ˜¯ä¸€ä¸ªå¼€æ”¾çš„ä¾¿ç­¾å¢™ï¼Œæ¯ä¸ªäººéƒ½å¯ä»¥è´´ä¸Šè‡ªå·±çš„æƒ³æ³•ã€çµæ„Ÿã€ç¬”è®°ã€‚
            </p>
            <div style="margin:16px 0;padding:12px;background:rgba(201,168,108,0.1);border-radius:8px;">
                <p style="margin:8px 0;"><strong>ğŸ¯ æ“ä½œæ–¹å¼</strong></p>
                <p style="margin:4px 0;font-size:0.9rem;">â€¢ ç¼©æ”¾ï¼šæ»šè½® / åŒæŒ‡æåˆ / å³ä¸‹è§’æ»‘å—</p>
                <p style="margin:4px 0;font-size:0.9rem;">â€¢ æ‹–åŠ¨ï¼šé¼ æ ‡/å•æŒ‡æ‹–åŠ¨ç©ºç™½åŒºæˆ–ä¾¿ç­¾</p>
                <p style="margin:4px 0;font-size:0.9rem;">â€¢ æœç´¢ï¼šå³ä¸Šè§’æœç´¢å›¾æ ‡</p>
            </div>
            <div style="margin:16px 0;padding:12px;background:rgba(201,168,108,0.05);border-radius:8px;">
                <p style="margin:8px 0;"><strong>ğŸ“ å¦‚ä½•æŠ•ç¨¿</strong></p>
                <p style="margin:4px 0;font-size:0.9rem;">ç¼–è¾‘ <code style="background:#f5e9d3;padding:2px 6px;border-radius:3px;">notes-data.json</code> æ–‡ä»¶ï¼Œæ·»åŠ ä½ çš„ä¾¿ç­¾</p>
                <p style="margin:4px 0;font-size:0.9rem;">æ”¯æŒ Markdownã€è‡ªå®šä¹‰é¢œè‰²ã€å›¾ç‰‡èƒŒæ™¯</p>
            </div>
            <p style="margin:16px 0 8px;text-align:center;color:#8b6f47;font-size:0.85rem;">
                Â© ç†µ Â· 2026
            </p>
            <button class="modal-close" id="closeModalBtn">å¼€å§‹æ¢ç´¢ ğŸš€</button>
        </div>
    </div>

    <script>
        (function() {
            // å¢™é¢å¤§å°é…ç½® - å¯ä»¥è½»æ¾ä¿®æ”¹è¿™é‡Œæ¥æ”¹å˜å¢™é¢å°ºå¯¸
            const WALL_WIDTH = 10000;
            const WALL_HEIGHT = 10000;

            const wall = document.getElementById('wall');
            const wrapper = document.getElementById('wallWrapper');
            // const slider = document.getElementById('zoomSlider'); // å·²ç§»é™¤æ»‘å—
            // const zoomSpan = document.getElementById('zoomPercent'); // å·²ç§»é™¤æ»‘å—

            // è®¾ç½®å¢™é¢å¤§å°
            wall.style.width = WALL_WIDTH + 'px';
            wall.style.height = WALL_HEIGHT + 'px';

            let maxZIndex = 1000;
            let currentScale = 1.0; // å½“å‰ç¼©æ”¾å€¼

            // å·¥å…·å‡½æ•°ï¼šéšæœºèŒƒå›´
            const random = (min, max) => Math.random() * (max - min) + min;

            // â”€â”€ å¯è§å­—ç¬¦è®¡æ•°ï¼šå‰¥ç¦»æ‰€æœ‰ Markdown è¯­æ³•ç¬¦å·å’Œ URLï¼Œåªæ•°å®é™…å†…å®¹ â”€â”€
            const MAX_CHARS = 100;
            function countVisible(text) {
                if (!text) return 0;
                return text
                    .replace(/!?\[([^\]]*?)\]\([^)]*?\)/g, '$1') // é“¾æ¥/å›¾ç‰‡ï¼šåªä¿ç•™æ˜¾ç¤ºæ–‡å­—
                    .replace(/```[\s\S]*?```/g, m => m.slice(3, -3).trim()) // ä»£ç å—
                    .replace(/`([^`]*?)`/g, '$1')   // è¡Œå†…ä»£ç 
                    .replace(/^#{1,6}\s+/gm, '')     // æ ‡é¢˜ç¬¦å·
                    .replace(/[*_~]{1,3}/g, '')      // ç²—ä½“/æ–œä½“/åˆ é™¤çº¿ç¬¦å·
                    .replace(/^>\s*/gm, '')           // å¼•ç”¨ç¬¦å·
                    .replace(/^[-*+]\s+/gm, '')       // æ— åºåˆ—è¡¨ç¬¦å·
                    .replace(/^\d+\.\s+/gm, '')       // æœ‰åºåˆ—è¡¨ç¬¦å·
                    .replace(/^[-*_]{3,}\s*$/gm, '')  // æ°´å¹³çº¿
                    .replace(/\n/g, '')               // æ¢è¡Œä¸è®¡å­—æ•°
                    .length;
            }

            function truncateText(text) {
                if (!text) return '';
                if (countVisible(text) <= MAX_CHARS) return text;
                // é€æ­¥æ‰«æåŸæ–‡ï¼Œè·³è¿‡ä¸è®¡å­—æ•°çš„éƒ¨åˆ†ï¼Œè¾¾åˆ°ä¸Šé™æ—¶æˆªæ–­
                let visible = 0;
                let i = 0;
                while (i < text.length && visible < MAX_CHARS) {
                    const rest = text.slice(i);
                    let m;
                    // é“¾æ¥/å›¾ç‰‡ [æ˜¾ç¤ºæ–‡å­—](url) â†’ åªè®¡æ˜¾ç¤ºæ–‡å­—
                    if ((m = rest.match(/^!?\[([^\]]*?)\]\([^)]*?\)/))) {
                        visible += m[1].length; i += m[0].length; continue;
                    }
                    // ä»£ç å— ```...```
                    if ((m = rest.match(/^```[\s\S]*?```/))) {
                        visible += m[0].slice(3,-3).trim().replace(/\n/g,'').length;
                        i += m[0].length; continue;
                    }
                    // è¡Œå†…ä»£ç  `...`
                    if ((m = rest.match(/^`([^`]*?)`/))) {
                        visible += m[1].length; i += m[0].length; continue;
                    }
                    // æ ‡é¢˜ç¬¦å· # ## ...ï¼ˆè¡Œé¦–ï¼‰
                    if ((m = rest.match(/^#{1,6}\s+/))) { i += m[0].length; continue; }
                    // ç²—ä½“/æ–œä½“/åˆ é™¤çº¿ç¬¦å·
                    if ((m = rest.match(/^[*_~]{1,3}/))) { i += m[0].length; continue; }
                    // å¼•ç”¨ç¬¦å· > ï¼ˆè¡Œé¦–ï¼‰
                    if ((m = rest.match(/^>\s*/))) { i += m[0].length; continue; }
                    // åˆ—è¡¨ç¬¦å·ï¼ˆè¡Œé¦–ï¼‰
                    if ((m = rest.match(/^[-*+]\s+|^\d+\.\s+/))) { i += m[0].length; continue; }
                    // æ°´å¹³çº¿
                    if ((m = rest.match(/^[-*_]{3,}\s*\n/))) { i += m[0].length; continue; }
                    // æ¢è¡Œä¸è®¡
                    if (text[i] === '\n') { i++; continue; }
                    visible++;
                    i++;
                }
                return text.slice(0, i) + 'â€¦';
            }

            // Markdown æ¸²æŸ“ï¼ˆå¸¦ç¼“å­˜ï¼Œæ‰€æœ‰é“¾æ¥ target="_blank"ï¼‰
            function renderMarkdown(text) {
                if (typeof marked === 'undefined') return text;
                if (!mdCache.has(text)) {
                    try { 
                        const html = marked.parse(text);
                        // æ‰€æœ‰é“¾æ¥æ”¹ä¸º target="_blank"
                        const withTarget = html.replace(/<a href=/g, '<a target="_blank" rel="noopener noreferrer" href=');
                        mdCache.set(text, withTarget);
                    } catch(e) { 
                        mdCache.set(text, text); 
                    }
                }
                return mdCache.get(text);
            }

            // marked å°±ç»ªåé‡æ–°æ¸²æŸ“ï¼ˆå¸¦ç¼“å­˜ï¼Œé¿å…é‡å¤è§£æï¼‰
            const mdCache = new Map();
            const MAX_CACHE_SIZE = 500;
            
            // é…ç½® marked æ”¯æŒæ¢è¡Œ
            if (typeof marked !== 'undefined') {
                marked.setOptions({
                    breaks: true,  // å°† 
 è½¬æ¢ä¸º <br>
                    gfm: true      // GitHub Flavored Markdown
                });
            }
            
            function rewireMarkdown() {
                if (typeof marked === 'undefined') return;
                document.querySelectorAll('.note-content[data-raw]').forEach(el => {
                    const raw = el.dataset.raw;
                    if (!mdCache.has(raw)) {
                        try { mdCache.set(raw, marked.parse(raw)); } catch(e) { mdCache.set(raw, raw); }
                    }
                    el.innerHTML = mdCache.get(raw);
                    delete el.dataset.raw;
                });
            }
            document.querySelector('script[src*="marked"]')
                ?.addEventListener('load', rewireMarkdown);



            // â”€â”€ è™šæ‹Ÿæ»šåŠ¨ç®¡ç†å™¨ï¼šå¤§é‡ä¾¿ç­¾æ—¶åªæ¸²æŸ“å¯è§åŒºåŸŸ â”€â”€
            const BUFFER = 2000;  // è§†å£å¤–æ‰© 2000px ç¼“å†²åŒºï¼ˆé¿å…é¢‘ç¹åˆ‡æ¢ï¼‰
            let allNotesData = [];  // æ‰€æœ‰ä¾¿ç­¾çš„åŸå§‹æ•°æ®
            let renderedNotes = new Map();  // noteId â†’ DOM element
            let viewportCheckTimer = null;

            function addNoteData(text, style, author) {
                const id = `note-${allNotesData.length}`;
                const left = Math.random() * (WALL_WIDTH - 240) + 50;
                const top  = Math.random() * (WALL_HEIGHT - 200) + 50;
                const rotate = Math.random() * 10 - 5;
                const noteData = { id, text, style, author, left, top, rotate };
                allNotesData.push(noteData);
                return noteData;  // è¿”å›æ•°æ®å¯¹è±¡
            }

            function isInViewport(noteData) {
                const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                const scale = currentScale || 1;
                // wall ä¸­å¿ƒåœ¨è§†å£ä¸­å¿ƒï¼Œtranslate æ˜¯åç§»é‡
                const viewCenterX = WALL_WIDTH / 2 - wallTranslateX / scale;
                const viewCenterY = WALL_HEIGHT / 2 - wallTranslateY / scale;
                // è§†å£åœ¨å¢™åæ ‡ç³»çš„èŒƒå›´
                const viewX = viewCenterX - vw / (2 * scale);
                const viewY = viewCenterY - vh / (2 * scale);
                const viewW = vw / scale;
                const viewH = vh / scale;
                // ä¾¿ç­¾åŒ…å›´ç›’ï¼ˆå« bufferï¼‰
                const noteX = noteData.left - BUFFER;
                const noteY = noteData.top  - BUFFER;
                const noteW = 240 + BUFFER * 2;
                const noteH = 200 + BUFFER * 2;
                // AABB ç¢°æ’æ£€æµ‹
                return !(noteX + noteW < viewX || noteX > viewX + viewW ||
                         noteY + noteH < viewY || noteY > viewY + viewH);
            }

            function updateVisibleNotes() {
                const toRender = new Set();
                const toRemove = [];

                // æ£€æŸ¥å“ªäº›ä¾¿ç­¾åº”è¯¥æ˜¾ç¤º
                allNotesData.forEach(data => {
                    if (isInViewport(data)) {
                        toRender.add(data.id);
                        if (!renderedNotes.has(data.id)) {
                            renderNote(data);
                        }
                    }
                });

                // ç§»é™¤ä¸å¯è§çš„ä¾¿ç­¾ï¼ˆé‡Šæ”¾ DOMï¼‰
                renderedNotes.forEach((el, id) => {
                    if (!toRender.has(id)) {
                        toRemove.push(id);
                    }
                });

                toRemove.forEach(id => {
                    const el = renderedNotes.get(id);
                    if (el) {
                        // æ¸…ç† Intersection Observerï¼ˆå¦‚æœæœ‰ï¼‰
                        if (imgObserver && el.dataset.bgImg) {
                            imgObserver.unobserve(el);
                        }
                        // ç§»é™¤ DOM
                        if (el.parentNode) el.parentNode.removeChild(el);
                    }
                    renderedNotes.delete(id);
                });
            }

            function renderNote(data) {
                const note = createNote(data.text, data.left, data.top, data.rotate, data.style, data.author);
                note.dataset.noteId = data.id;
                wall.appendChild(note);
                renderedNotes.set(data.id, note);
            }

            // ç¼©æ”¾/æ‹–åŠ¨åå»¶è¿Ÿè§¦å‘ï¼ˆ1000ms debounceï¼Œé¿å…é¢‘ç¹æ£€æŸ¥ï¼‰
            function scheduleViewportCheck() {
                if (viewportCheckTimer) clearTimeout(viewportCheckTimer);
                viewportCheckTimer = setTimeout(updateVisibleNotes, 1000);
            }

            // â”€â”€ å›¾ç‰‡èƒŒæ™¯æ‡’åŠ è½½ï¼ˆIntersection Observerï¼‰â”€â”€
            let imgObserver = null;
            function initImgObserver() {
                if (imgObserver) return;
                imgObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const note = entry.target;
                            const imgUrl = note.dataset.bgImg;
                            if (imgUrl) {
                                // é¢„åŠ è½½å›¾ç‰‡
                                const img = new Image();
                                img.decoding = 'async';  // å¼‚æ­¥è§£ç ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
                                img.onload = () => {
                                    requestAnimationFrame(() => {
                                        note.style.setProperty('background-image', `url("${imgUrl}")`, 'important');
                                        note.classList.add('img-loaded');
                                        delete note.dataset.bgImg;
                                    });
                                };
                                img.onerror = () => note.classList.add('img-error');
                                img.src = imgUrl;
                                imgObserver.unobserve(note);
                            }
                        }
                    });
                }, { 
                    root: wrapper,
                    rootMargin: '300px',  // æå‰ 300px åŠ è½½
                    threshold: 0
                });
            }

            // åˆ›å»ºä¾¿ç­¾ï¼ˆæ”¯æŒ styleï¼šé¢œè‰²å / #hex / å›¾ç‰‡é“¾æ¥ï¼Œä»¥åŠå¯é€‰ author ç½²åï¼‰
            function createNote(mdText, left, top, rotate = null, style = 'yellow', author = '') {
                const note = document.createElement('div');
                note.className = 'note';

                // â”€â”€ èƒŒæ™¯æ ·å¼ â”€â”€
                if (typeof style === 'string') {
                    if (style.startsWith('http') || style.startsWith('//')) {
                        note.classList.add('has-image-bg');
                        note.dataset.bgImg = style;  // å­˜åˆ° data å±æ€§ï¼Œå»¶è¿ŸåŠ è½½
                        initImgObserver();
                        imgObserver.observe(note);  // è¿›å…¥è§†å£åæ‰åŠ è½½
                    } else if (style.startsWith('#')) {
                        note.classList.add('custom-color');
                        note.style.background = `linear-gradient(145deg, ${lightenColor(style, 5)}, ${darkenColor(style, 5)})`;
                    } else {
                        note.classList.add(`style-${style}`);
                    }
                } else {
                    note.classList.add('style-yellow');
                }

                // â”€â”€ æ—‹è½¬ & ä½ç½® â”€â”€
                const rot = (rotate !== null) ? rotate : random(-5, 6);
                note.style.transform = `rotate(${rot}deg)`;
                note.dataset.rotate = rot;  // ä¿å­˜æ—‹è½¬è§’åº¦åˆ° data å±æ€§
                const noteLeft = left !== null ? left : random(200, WALL_WIDTH - 200);
                const noteTop  = top  !== null ? top  : random(200, WALL_HEIGHT - 200);
                note.style.left = noteLeft + 'px';
                note.style.top  = noteTop  + 'px';
                // ç¡®ä¿ä¾¿ç­¾æœ‰æ˜ç¡®å®šä½ï¼Œé˜²æ­¢æ‹–åŠ¨æ—¶åæ ‡é”™ä¹±
                note.style.position = 'absolute';
                note.style.zIndex = Math.floor(random(10, 500));

                // â”€â”€ æ­£æ–‡å†…å®¹ â”€â”€
                const contentSpan = document.createElement('span');
                contentSpan.className = 'note-content';
                const truncated = truncateText(mdText);
                const html = renderMarkdown(truncated);
                contentSpan.innerHTML = html;
                // è‹¥ marked å°šæœªå°±ç»ªï¼ˆdeferï¼‰ï¼Œä¿å­˜åŸæ–‡ä¾› rewireMarkdown è¡¥æ¸²æŸ“
                if (html === truncated && truncated.trim()) {
                    contentSpan.dataset.raw = truncated;
                }
                note.appendChild(contentSpan);

                // â”€â”€ ç½²åï¼ˆæœ‰ author æ—¶æ˜¾ç¤ºï¼‰â”€â”€
                if (author && author.trim()) {
                    const authorEl = document.createElement('span');
                    authorEl.className = 'note-author';
                    authorEl.textContent = 'â€” ' + author.trim();
                    note.appendChild(authorEl);
                }

                makeDraggable(note);
                return note;
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šè°ƒæ•´é¢œè‰²äº®åº¦
            function lightenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
            }
            
            function darkenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R>255?255:R<0?0:R)*0x10000 + (G>255?255:G<0?0:G)*0x100 + (B>255?255:B<0?0:B)).toString(16).slice(1);
            }

            // â”€â”€ ä¾¿ç­¾æ‹–æ‹½ï¼šäº‹ä»¶å§”æ‰˜åˆ° wallï¼Œé¿å… N å¼ ä¾¿ç­¾ Ã— 2 ä¸ªç›‘å¬å™¨ â”€â”€
            // æ‹–æ‹½çŠ¶æ€ï¼ˆå…¨å±€å•ä¾‹ï¼ŒåŒæ—¶åªèƒ½æ‹–ä¸€å¼ ï¼‰
            let dragNote = null, dragStartX = 0, dragStartY = 0;
            let dragInitLeft = 0, dragInitTop = 0;
            let dragHasMoved = false;
            let dragVX = 0, dragVY = 0, dragLastX = 0, dragLastY = 0, dragLastT = 0;
            let dragRafId = null;
            // é¢„å­˜ä¾¿ç­¾å°ºå¯¸ï¼Œé¿å…æ‹–åŠ¨ä¸­åå¤è§¦å‘ layout
            const NOTE_W = 240, NOTE_H = 200;

            function noteDragStart(note, clientX, clientY) {
                dragNote = note;
                dragStartX = clientX; dragStartY = clientY;
                // ä¿ç•™æ—‹è½¬è§’åº¦ï¼Œåªæ¸…é™¤ translate
                const rotate = note.dataset.rotate || 0;
                note.style.transform = `rotate(${rotate}deg)`;
                dragInitLeft  = parseFloat(note.style.left)  || 0;
                dragInitTop   = parseFloat(note.style.top)   || 0;
                dragLastX = clientX; dragLastY = clientY;
                dragLastT = Date.now();
                dragVX = 0; dragVY = 0;
                dragHasMoved = false;
                maxZIndex++;
                note.style.zIndex = maxZIndex;
                note.style.transition = 'none';
            }

            function noteDragMove(clientX, clientY) {
                if (!dragNote) return;
                const now = Date.now(), dt = now - dragLastT;
                if (dt > 0) {
                    dragVX = (clientX - dragLastX) / dt * 16;
                    dragVY = (clientY - dragLastY) / dt * 16;
                }
                dragLastX = clientX; dragLastY = clientY; dragLastT = now;

                const dx = clientX - dragStartX, dy = clientY - dragStartY;
                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragHasMoved = true;

                // è®¡ç®—æœ€ç»ˆä½ç½®ï¼ˆå¸¦è¾¹ç•Œé™åˆ¶ï¼‰
                let newLeft = Math.min(WALL_WIDTH - 30,  Math.max(-NOTE_W + 30, dragInitLeft + dx));
                let newTop  = Math.min(WALL_HEIGHT - 30, Math.max(-NOTE_H + 30, dragInitTop  + dy));

                // rAF èŠ‚æµï¼šæ‹–æ‹½ä¸­ç”¨ translate ç›¸å¯¹åç§»ï¼ˆç›¸å¯¹äºåŸå§‹ left/topï¼‰
                if (dragRafId) cancelAnimationFrame(dragRafId);
                dragRafId = requestAnimationFrame(() => {
                    if (dragNote) {
                        dragNote.style.transition = 'none';
                        // æ‹–åŠ¨æ—¶ç›´æ¥ä¿®æ”¹ left/topï¼Œä¸ç”¨ transform
                        dragNote.style.left = newLeft + 'px';
                        dragNote.style.top = newTop + 'px';
                    }
                });
            }

            function noteDragEnd() {
                if (!dragNote) return;
                cancelAnimationFrame(dragRafId);
                const note = dragNote;
                dragNote = null;
                dragRafId = null;
                
                if (!dragHasMoved) {
                    // æœªç§»åŠ¨ï¼Œç›´æ¥æ¢å¤
                    note.style.transform = '';
                    note.style.transition = '';
                    return;
                }

                // è¯»å–å½“å‰ä½ç½®ï¼ˆå·²åœ¨æ‹–åŠ¨ä¸­æ›´æ–°åˆ° left/topï¼‰
                let curX = parseFloat(note.style.left) || dragInitLeft;
                let curY = parseFloat(note.style.top) || dragInitTop;

                // é€Ÿåº¦è¡°å‡ï¼ˆæƒ¯æ€§æ»‘åŠ¨ï¼‰
                let finalX = curX + dragVX * 0.6;
                let finalY = curY + dragVY * 0.6;

                // è¾¹ç•Œé™åˆ¶
                finalX = Math.min(WALL_WIDTH - 30, Math.max(-NOTE_W + 30, finalX));
                finalY = Math.min(WALL_HEIGHT - 30, Math.max(-NOTE_H + 30, finalY));

                // è®¾ç½®æœ€ç»ˆä½ç½®
                note.style.left = finalX + 'px';
                note.style.top  = finalY + 'px';
                // ç²˜æ»æ•ˆæœç”±æƒ¯æ€§è®¡ç®—å®ç°ï¼Œæ— éœ€ CSS transition
            }

            // wall å±‚ç»Ÿä¸€å§”æ‰˜ mousedown / touchstart
            function initNoteDrag() {
                wall.addEventListener('mousedown', (e) => {
                    const note = e.target.closest('.note');
                    if (!note || e.button !== 0) return;
                    if (e.target.closest('a')) return; // è¶…é“¾æ¥ä¸æ‹–
                    e.preventDefault(); e.stopPropagation();
                    noteDragStart(note, e.clientX, e.clientY);
                    document.addEventListener('mousemove', onDocMouseMove);
                    document.addEventListener('mouseup',  onDocMouseUp,  { once: true });
                });
                wall.addEventListener('touchstart', (e) => {
                    if (e.touches.length !== 1) return;
                    const note = e.target.closest('.note');
                    if (!note) return;
                    if (e.target.closest('a')) return;
                    e.preventDefault(); e.stopPropagation();
                    noteDragStart(note, e.touches[0].clientX, e.touches[0].clientY);
                    document.addEventListener('touchmove', onDocTouchMove, { passive: false });
                    document.addEventListener('touchend',  onDocTouchEnd,  { once: true });
                    document.addEventListener('touchcancel', onDocTouchEnd, { once: true });
                }, { passive: false });
            }
            function onDocMouseMove(e) { noteDragMove(e.clientX, e.clientY); }
            function onDocMouseUp()    { noteDragEnd(); document.removeEventListener('mousemove', onDocMouseMove); }
            function onDocTouchMove(e) { e.preventDefault(); if (e.touches.length===1) noteDragMove(e.touches[0].clientX, e.touches[0].clientY); }
            function onDocTouchEnd()   { noteDragEnd(); document.removeEventListener('touchmove', onDocTouchMove); }
            function makeDraggable(_el) { /* äº‹ä»¶å§”æ‰˜ï¼Œæ— éœ€é€å…ƒç´ ç»‘å®š */ }

            // â”€â”€ zoom-control å½»åº•éš”ç¦»æ‰€æœ‰è§¦æ‘¸/é¼ æ ‡äº‹ä»¶ â”€â”€
            function isolateZoomControl() {
                const zoomCtrl = document.querySelector('.zoom-control');
                if (!zoomCtrl) return;
                
                ['mousedown','touchstart','touchmove','touchend','click'].forEach(evt => {
                    zoomCtrl.addEventListener(evt, (e) => {
                        e.stopPropagation();  // é˜»æ­¢å†’æ³¡åˆ° wall/wrapper
                    }, { passive: evt !== 'touchstart' && evt !== 'touchmove' });
                });
            }

            // åˆå§‹åŒ–ä¾¿ç­¾ï¼ˆå…¨éƒ¨ç›´æ¥æ¸²æŸ“ï¼Œç¦ç”¨è™šæ‹Ÿæ»šåŠ¨ï¼‰
            function initDefaultNotes(data = null) {
                if (!data || !data.notes) return;
                
                const noteCount = data.notes.length;
                
                // æ”¶é›†æ‰€æœ‰ä¾¿ç­¾æ•°æ®ç”¨äºæœç´¢
                allNotesForSearch = data.notes.map((item, i) => ({
                    id: `note-${i}`,
                    text: item.text,
                    style: item.style || 'yellow',
                    author: item.author || '',
                    left: null,
                    top: null
                }));
                
                // å…¨éƒ¨ç›´æ¥æ¸²æŸ“ï¼ˆç¦ç”¨è™šæ‹Ÿæ»šåŠ¨ï¼‰
                const frag = document.createDocumentFragment();
                data.notes.forEach((item, i) => {
                    const note = createNote(
                        item.text,
                        null, null, null,
                        item.style  || 'yellow',
                        item.author || ''
                    );
                    note.dataset.noteId = `note-${i}`;
                    // ä¿å­˜ä½ç½®ç”¨äºæœç´¢å®šä½
                    const left = parseFloat(note.style.left) || 0;
                    const top = parseFloat(note.style.top) || 0;
                    allNotesForSearch[i].left = left;
                    allNotesForSearch[i].top = top;
                    frag.appendChild(note);
                });
                wall.appendChild(frag);
                console.log(`âœ“ å·²æ¸²æŸ“ ${noteCount} å¼ ä¾¿ç­¾`);
                console.log('ğŸ“Š allNotesForSearch æ•°æ®é‡:', allNotesForSearch.length);
                
                // æš´éœ²åˆ°å…¨å±€ä¾¿äºè°ƒè¯•
                window.debugSearch = () => {
                    console.log('allNotesForSearch:', allNotesForSearch);
                    console.log('ç¤ºä¾‹æ•°æ®:', allNotesForSearch[0]);
                };
                console.log('ğŸ’¡ å¯åœ¨æ§åˆ¶å°è¿è¡Œ debugSearch() æŸ¥çœ‹æœç´¢æ•°æ®');
            }

            function renderInBatches() {
                const BATCH_SIZE = 20;  // æ¯æ‰¹ 20 ä¸ª
                let index = 0;
                
                function renderBatch(deadline) {
                    // åœ¨ç©ºé—²æ—¶é—´æ¸²æŸ“ï¼Œæ¯æ‰¹æœ€å¤š 50ms
                    const endTime = deadline ? deadline.timeRemaining() : 50;
                    const startTime = performance.now();

                    while (index < allNotesData.length && 
                           (performance.now() - startTime) < endTime) {
                        const data = allNotesData[index];
                        if (isInViewport(data)) {
                            renderNote(data);
                        }
                        index++;
                    }

                    // æ›´æ–°è¿›åº¦
                    const loadingText = document.getElementById('loadingText');
                    if (loadingText) {
                        const pct = Math.round((index / allNotesData.length) * 100);
                        loadingText.textContent = `æ­£åœ¨æ¸²æŸ“ä¾¿ç­¾... ${index}/${allNotesData.length} (${pct}%)`;
                    }

                    if (index < allNotesData.length) {
                        if (typeof requestIdleCallback !== 'undefined') {
                            requestIdleCallback(renderBatch);
                        } else {
                            setTimeout(() => renderBatch(null), 16);
                        }
                    } else {
                        console.log(`âœ“ å·²æ¸²æŸ“ ${renderedNotes.size}/${allNotesData.length} å¼ ä¾¿ç­¾`);
                        const loading = document.getElementById('loadingHint');
                        if (loading) setTimeout(() => loading.style.display = 'none', 300);
                    }
                }

                // å¯åŠ¨åˆ†æ‰¹æ¸²æŸ“
                if (typeof requestIdleCallback !== 'undefined') {
                    requestIdleCallback(renderBatch);
                } else {
                    setTimeout(() => renderBatch(null), 0);
                }
            }

            // è®¾å¤‡æ£€æµ‹
            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            const mobileDevice = isMobileDevice();
            
            // å­˜å‚¨å…‰æ ‡ä½ç½®
            let cursorPos = { x: 0, y: 0 };
            
            // æ›´æ–°å…‰æ ‡ä½ç½®ï¼ˆthrottleï¼šæ¯å¸§æœ€å¤šæ›´æ–°ä¸€æ¬¡ï¼‰
            let cursorRafPending = false;
            wrapper.addEventListener('mousemove', (e) => {
                if (cursorRafPending) return;
                cursorRafPending = true;
                requestAnimationFrame(() => {
                    cursorPos.x = e.clientX;
                    cursorPos.y = e.clientY;
                    cursorRafPending = false;
                });
            }, { passive: true });

            // ========== ç¼©æ”¾é€»è¾‘ (çº¯ transformï¼ŒGPU åŠ é€Ÿ) ==========
            let wallTranslateX = 0, wallTranslateY = 0;  // å¢™çš„å¹³ç§»é‡ï¼ˆpxï¼‰

            function updateZoom(newScale, useCursor = false) {
                const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                if (vw === 0 || vh === 0) return;
                const oldScale = currentScale;
                

                // ç¡®å®šç¼©æ”¾é”šç‚¹
                let focusX = vw / 2, focusY = vh / 2;
                if (useCursor && !mobileDevice) {
                    focusX = cursorPos.x;
                    focusY = cursorPos.y;
                }

                // ç¼©æ”¾æ—¶ä¿æŒé”šç‚¹ä¸åŠ¨ï¼š
                // é”šç‚¹åœ¨å¢™åæ ‡ç³»çš„ä½ç½® = (focusX - vw/2 - wallTranslateX) / oldScale
                // æ–°å¹³ç§»é‡ = wallTranslateX - (é”šç‚¹å¢™åæ ‡) * (newScale - oldScale)
                const anchorWallX = (focusX - vw/2 - wallTranslateX) / oldScale;
                const anchorWallY = (focusY - vh/2 - wallTranslateY) / oldScale;
                wallTranslateX -= anchorWallX * (newScale - oldScale);
                wallTranslateY -= anchorWallY * (newScale - oldScale);

                // é™åˆ¶å¹³ç§»èŒƒå›´ï¼Œç¡®ä¿å¢™ä¸ä¼šå®Œå…¨ç§»å‡ºè§†å£
                const scaledW = WALL_WIDTH * newScale, scaledH = WALL_HEIGHT * newScale;
                const maxOffsetX = Math.max(0, (scaledW - vw) / 2);
                const maxOffsetY = Math.max(0, (scaledH - vh) / 2);
                wallTranslateX = Math.max(-maxOffsetX, Math.min(maxOffsetX, wallTranslateX));
                wallTranslateY = Math.max(-maxOffsetY, Math.min(maxOffsetY, wallTranslateY));

                applyWallTransform(newScale);
                currentScale = newScale;
                zoomSpan.innerText = Math.round(newScale * 100) + '%';
            }

            function applyWallTransform(scale) {
                wall.style.transform = `translate3d(calc(-50% + ${wallTranslateX}px), calc(-50% + ${wallTranslateY}px), 0) scale(${scale})`;
                // è™šæ‹Ÿæ»šåŠ¨å·²ç¦ç”¨ï¼Œæ— éœ€æ£€æŸ¥
            }

            // æ»‘å—å·²ç§»é™¤ï¼Œä»…ä¿ç•™æ»šè½®/æ‰‹åŠ¿ç¼©æ”¾

            // é‡ç½®åˆ°å¢™é¢ä¸­å¿ƒ
            function scrollToCenter() {
                wallTranslateX = 0;
                wallTranslateY = 0;
                // slider.value = currentScale; // å·²ç§»é™¤æ»‘å—
                // zoomSpan.innerText = Math.round(currentScale * 100) + '%'; // å·²ç§»é™¤æ»‘å—
                applyWallTransform(currentScale);
            }

            // åˆå§‹åŒ–ï¼šåŠ è½½ä¾¿ç­¾ â†’ æ¸²æŸ“ â†’ æ»šåŠ¨å®šä½
            window.addEventListener('DOMContentLoaded', () => {
            // â”€â”€ æœç´¢åŠŸèƒ½ â”€â”€
            let allNotesForSearch = [];  // æ‰€æœ‰ä¾¿ç­¾æ•°æ®ï¼ˆç”¨äºæœç´¢ï¼‰
            
            function initSearch() {
                const searchIcon = document.getElementById('searchIcon');
                const searchPanel = document.getElementById('searchPanel');
                const searchInput = document.getElementById('searchInput');
                const searchResults = document.getElementById('searchResults');
                
                if (!searchIcon || !searchPanel || !searchInput || !searchResults) {
                    console.error('âŒ æœç´¢å…ƒç´ æœªæ‰¾åˆ°');
                    return;
                }
                
                console.log('âœ“ æœç´¢å…ƒç´ å·²æ‰¾åˆ°ï¼Œå¼€å§‹ç»‘å®šäº‹ä»¶');
                
                // ç‚¹å‡»æœç´¢å›¾æ ‡åˆ‡æ¢é¢æ¿
                searchIcon.addEventListener('click', (e) => {
                    e.stopPropagation();  // é˜»æ­¢å†’æ³¡
                    const isVisible = searchPanel.style.display === 'block';
                    searchPanel.style.display = isVisible ? 'none' : 'block';
                    if (!isVisible) {
                        searchInput.focus();
                    }
                });
                
                // ç‚¹å‡»å¤–éƒ¨å…³é—­æœç´¢é¢æ¿
                document.addEventListener('click', (e) => {
                    if (!searchPanel.contains(e.target) && 
                        e.target !== searchIcon && 
                        !searchIcon.contains(e.target)) {
                        searchPanel.style.display = 'none';
                    }
                });
                
                // é¢æ¿å†…ç‚¹å‡»ä¸å…³é—­
                searchPanel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // æœç´¢è¾“å…¥
                searchInput.addEventListener('input', (e) => {
                    const keyword = e.target.value.trim().toLowerCase();
                    console.log('ğŸ” æœç´¢å…³é”®è¯:', keyword);
                    console.log('ğŸ“Š æ€»ä¾¿ç­¾æ•°:', allNotesForSearch.length);
                    
                    if (!keyword) {
                        searchResults.innerHTML = '<div style="color:#9e8870;padding:20px;text-align:center">è¾“å…¥å…³é”®è¯æœç´¢ä¾¿ç­¾</div>';
                        return;
                    }
                    
                    // è°ƒè¯•ï¼šè¾“å‡ºå‰3ä¸ªä¾¿ç­¾å†…å®¹
                    if (allNotesForSearch.length > 0) {
                        console.log('ğŸ“ å‰3ä¸ªä¾¿ç­¾å†…å®¹ç¤ºä¾‹:');
                        allNotesForSearch.slice(0, 3).forEach((note, i) => {
                            console.log(`  [${i}]`, note.text?.slice(0, 50), 'ä½œè€…:', note.author);
                        });
                    }
                    
                    // æœç´¢ä¾¿ç­¾ï¼ˆå†…å®¹å’Œç½²åï¼Œå»é™¤ Markdown ç¬¦å·ï¼‰
                    const matches = allNotesForSearch.filter(note => {
                        // å»é™¤ Markdown ç¬¦å·åå†æœç´¢
                        const cleanText = (note.text || '')
                            .replace(/[*_~`#>]/g, '')  // ç§»é™¤ç¬¦å·
                            .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // é“¾æ¥åªä¿ç•™æ–‡å­—
                            .toLowerCase();
                        const author = (note.author || '').toLowerCase();
                        const match = cleanText.includes(keyword) || author.includes(keyword);
                        if (match) {
                            console.log('  âœ“ åŒ¹é…:', note.text?.slice(0, 60));
                        }
                        return match;
                    });
                    
                    console.log('âœ… æ‰¾åˆ°', matches.length, 'æ¡åŒ¹é…');
                    
                    if (matches.length === 0) {
                        searchResults.innerHTML = '<div style="color:#9e8870;padding:20px;text-align:center">æœªæ‰¾åˆ°åŒ¹é…çš„ä¾¿ç­¾</div>';
                        return;
                    }
                    
                    // æ˜¾ç¤ºæœç´¢ç»“æœ
                    searchResults.innerHTML = matches.slice(0, 20).map((note, i) => {
                        const preview = note.text.replace(/[#*_~`>\[\]()]/g, '').slice(0, 80);
                        return `
                            <div class="search-result-item" data-note-id="${note.id || i}">
                                <div class="result-text">${preview}${preview.length < note.text.length ? '...' : ''}</div>
                                ${note.author ? `<div class="result-author">â€” ${note.author}</div>` : ''}
                            </div>
                        `;
                    }).join('');
                    
                    // ç‚¹å‡»ç»“æœå®šä½åˆ°ä¾¿ç­¾
                    searchResults.querySelectorAll('.search-result-item').forEach((item, i) => {
                        item.addEventListener('click', () => {
                            const noteData = matches[i];
                            if (noteData.left !== undefined && noteData.top !== undefined) {
                                // å®šä½åˆ°ä¾¿ç­¾ä½ç½®
                                const targetX = noteData.left - WALL_WIDTH / 2;
                                const targetY = noteData.top - WALL_HEIGHT / 2;
                                wallTranslateX = -targetX * currentScale;
                                wallTranslateY = -targetY * currentScale;
                                applyWallTransform(currentScale);
                                searchPanel.style.display = 'none';
                                
                                // é«˜äº®ä¾¿ç­¾ï¼ˆå¦‚æœå·²æ¸²æŸ“ï¼‰
                                setTimeout(() => {
                                    const noteEl = document.querySelector(`[data-note-id="${noteData.id}"]`);
                                    if (noteEl && noteEl.classList.contains('note')) {
                                        noteEl.style.animation = 'highlight 1s ease';
                                        setTimeout(() => noteEl.style.animation = '', 1000);
                                    }
                                }, 300);
                            }
                        });
                    });
                });
            }
            
            // é«˜äº®åŠ¨ç”»CSSï¼ˆæ·»åŠ åˆ° headï¼‰
            const highlightStyle = document.createElement('style');
            highlightStyle.textContent = `
                @keyframes highlight {
                    0%, 100% { box-shadow: 6px 6px 15px rgba(0,0,0,0.4); }
                    50% { box-shadow: 0 0 0 4px #ffd700, 6px 6px 15px rgba(0,0,0,0.4); }
                }
            `;
            document.head.appendChild(highlightStyle);


                // console.log('ğŸ§± ä¾¿ç­¾å¢™åˆå§‹åŒ–...'); // å·²æ³¨é‡Šå‡å°‘å¼€é”€
                makeWallDraggable();
                initNoteDrag();
                // ç¡®ä¿ DOM å®Œå…¨å°±ç»ªåå†åˆå§‹åŒ–æœç´¢
                setTimeout(() => {
                    initSearch();
                    // console.log('âœ“ æœç´¢åŠŸèƒ½å·²åˆå§‹åŒ–'); // å·²æ³¨é‡Šå‡å°‘å¼€é”€
                }, 100);
                scrollToCenter();
                // console.log('âœ“ å¢™é¢å°±ç»ª'); // å·²æ³¨é‡Šå‡å°‘å¼€é”€
                
                // å¸®åŠ©å›¾æ ‡ç‚¹å‡»äº‹ä»¶
                const helpIcon = document.getElementById('helpIcon');
                const infoModal = document.getElementById('infoModal');
                
                if (helpIcon && infoModal) {
                    helpIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        console.log('ğŸ“– æ‰“å¼€å¸®åŠ©å¼¹çª—');
                        infoModal.style.display = 'flex';
                        setTimeout(() => { infoModal.style.opacity = '1'; }, 10);
                    });
                    console.log('âœ“ å¸®åŠ©å›¾æ ‡äº‹ä»¶å·²ç»‘å®š');
                } else {
                    console.error('âŒ å¸®åŠ©å…ƒç´ æœªæ‰¾åˆ°', {helpIcon, infoModal});
                }
                
                // å…³é—­å¼¹çª—
                const closeBtn = document.getElementById('closeModalBtn');
                if (closeBtn && infoModal) {
                    const closeModal = () => {
                        console.log('ğŸ“– å…³é—­å¸®åŠ©å¼¹çª—');
                        infoModal.style.opacity = '0';
                        setTimeout(() => { infoModal.style.display = 'none'; }, 200);
                    };
                    
                    closeBtn.addEventListener('click', closeModal);
                    
                    // ç‚¹å‡»å¼¹çª—å¤–éƒ¨ä¹Ÿå…³é—­
                    infoModal.addEventListener('click', (e) => {
                        if (e.target === infoModal) {
                            closeModal();
                        }
                    });
                    
                    console.log('âœ“ å…³é—­æŒ‰é’®äº‹ä»¶å·²ç»‘å®š');
                }


            });

            window.addEventListener('load', async () => {
                const loading = document.getElementById('loadingHint');
                const loadingText = document.getElementById('loadingText');
                if (loading) loading.style.display = 'block';
                if (loadingText) loadingText.textContent = 'åŠ è½½ä¾¿ç­¾æ•°æ®...';
                
                try {
                    const response = await fetch(`notes-data.json?t=${Date.now()}`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    
                    const noteCount = data.notes?.length || 0;
                    if (loadingText) {
                        loadingText.textContent = `å·²åŠ è½½ ${noteCount} å¼ ä¾¿ç­¾`;
                    }
                    
                    initDefaultNotes(data);
                    
                    // æ‰€æœ‰ä¾¿ç­¾éƒ½ç›´æ¥æ¸²æŸ“ï¼Œç»Ÿä¸€å…³é—­ loading
                    setTimeout(() => {
                        if (loading) {
                            loading.style.display = 'none';
                            console.log('âœ“ åŠ è½½å®Œæˆï¼Œæ¸²æŸ“äº†', noteCount, 'å¼ ä¾¿ç­¾');
                        }
                    }, 300);
                } catch (error) {
                    console.warn('åŠ è½½ä¾¿ç­¾æ•°æ®å¤±è´¥:', error.message);
                    if (loadingText) loadingText.textContent = 'âš ï¸ åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ notes-data.json';
                    setTimeout(() => {
                        if (loading) loading.style.display = 'none';
                    }, 2000);
                }
            });

            // â”€â”€ å¢™é¢æ‰‹åŠ¿ç®¡ç†å™¨ï¼šç»Ÿä¸€å¤„ç†å•æŒ‡æ‹–åŠ¨ + åŒæŒ‡ç¼©æ”¾ â”€â”€
            function makeWallDraggable() {

                // â”€â”€ é¼ æ ‡æ‹–åŠ¨ï¼ˆæ¡Œé¢ç«¯ï¼‰â”€â”€
                let mouseDown = false;
                let mouseStartX, mouseStartY, mouseInitTX, mouseInitTY;
                let mouseVX = 0, mouseVY = 0, mouseLastX = 0, mouseLastY = 0, mouseLastT = 0;

                function onMouseDown(e) {
                    if (e.target === wall || e.target === wrapper) {
                        if (e.button !== 0) return;
                        e.preventDefault();
                        mouseDown = true;
                        mouseStartX = e.clientX;
                        mouseStartY = e.clientY;
                        mouseInitTX = wallTranslateX;
                        mouseInitTY = wallTranslateY;
                        mouseLastX = e.clientX;
                        mouseLastY = e.clientY;
                        mouseLastT = Date.now();
                        mouseVX = 0; mouseVY = 0;
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    }
                }
                function onMouseMove(e) {
                    if (!mouseDown) return;
                    // è®¡ç®—é€Ÿåº¦
                    const now = Date.now(), dt = now - mouseLastT;
                    if (dt > 0) {
                        mouseVX = (e.clientX - mouseLastX) / dt * 16;
                        mouseVY = (e.clientY - mouseLastY) / dt * 16;
                    }
                    mouseLastX = e.clientX; mouseLastY = e.clientY; mouseLastT = now;
                    
                    const dx = e.clientX - mouseStartX;
                    const dy = e.clientY - mouseStartY;
                    wallTranslateX = mouseInitTX + dx;
                    wallTranslateY = mouseInitTY + dy;
                    
                    const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                    const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                    const maxX = Math.max(0, (scaledW - vw) / 2);
                    const maxY = Math.max(0, (scaledH - vh) / 2);
                    wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                    wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));
                    applyWallTransform(currentScale);
                }
                function onMouseUp() {
                    mouseDown = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    // åº”ç”¨æƒ¯æ€§ï¼ˆè¡°å‡ç³»æ•° 0.5ï¼‰
                    const finalX = wallTranslateX + mouseVX * 0.5;
                    const finalY = wallTranslateY + mouseVY * 0.5;
                    
                    const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                    const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                    const maxX = Math.max(0, (scaledW - vw) / 2);
                    const maxY = Math.max(0, (scaledH - vh) / 2);
                    
                    wallTranslateX = Math.max(-maxX, Math.min(maxX, finalX));
                    wallTranslateY = Math.max(-maxY, Math.min(maxY, finalY));
                    applyWallTransform(currentScale);
                }
                wall.addEventListener('mousedown', onMouseDown);
                wrapper.addEventListener('mousedown', onMouseDown);

                // â”€â”€ è§¦æ‘¸æ‰‹åŠ¿ï¼ˆç§»åŠ¨ç«¯ï¼‰ï¼šå•æŒ‡æ‹–åŠ¨ + åŒæŒ‡ pinch ç¼©æ”¾ â”€â”€
                let touchState = 'idle';
                let dragStartX, dragStartY, dragInitTX, dragInitTY;
                let pinchInitDist, pinchInitScale, pinchInitMidX, pinchInitMidY;
                let pinchInitTX, pinchInitTY;

                function getTouchMidpoint(touches) {
                    return {
                        x: (touches[0].clientX + touches[1].clientX) / 2,
                        y: (touches[0].clientY + touches[1].clientY) / 2,
                    };
                }
                function getTouchDist(touches) {
                    const dx = touches[1].clientX - touches[0].clientX;
                    const dy = touches[1].clientY - touches[0].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }

                function onTouchStart(e) {
                    // å¦‚æœè§¦æ‘¸èµ·ç‚¹åœ¨ zoom-control å†…ï¼Œå¿½ç•¥ï¼ˆè®©æ»‘å—è‡ªå·±å¤„ç†ï¼‰
                    if (e.target.closest && e.target.closest('.zoom-control')) return;

                    if (e.touches.length === 1) {
                        if (e.target === wall || e.target === wrapper) {
                            e.preventDefault();
                            touchState = 'drag';
                            dragStartX = e.touches[0].clientX;
                            dragStartY = e.touches[0].clientY;
                            dragInitTX = wallTranslateX;
                            dragInitTY = wallTranslateY;
                        }
                    } else if (e.touches.length === 2) {
                        e.preventDefault();
                        touchState = 'pinch';
                        pinchInitDist  = getTouchDist(e.touches);
                        pinchInitScale = currentScale;
                        const mid = getTouchMidpoint(e.touches);
                        pinchInitMidX = mid.x;
                        pinchInitMidY = mid.y;
                        pinchInitTX = wallTranslateX;
                        pinchInitTY = wallTranslateY;
                    }
                }

                function onTouchMove(e) {
                    if (touchState === 'idle') return;
                    e.preventDefault();

                    if (touchState === 'drag' && e.touches.length === 1) {
                        const dx = e.touches[0].clientX - dragStartX;
                        const dy = e.touches[0].clientY - dragStartY;
                        wallTranslateX = dragInitTX + dx;
                        wallTranslateY = dragInitTY + dy;
                        const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                        const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                        const maxX = Math.max(0, (scaledW - vw) / 2);
                        const maxY = Math.max(0, (scaledH - vh) / 2);
                        wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                        wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));
                        applyWallTransform(currentScale);

                    } else if (e.touches.length === 2) {
                        // å¦‚æœä¸­é€”å˜ä¸ºåŒæŒ‡ï¼Œå‡çº§ä¸º pinch
                        if (touchState !== 'pinch') {
                            touchState = 'pinch';
                            pinchInitDist  = getTouchDist(e.touches);
                            pinchInitScale = currentScale;
                            const mid = getTouchMidpoint(e.touches);
                            pinchInitMidX = mid.x;
                            pinchInitMidY = mid.y;
                            pinchInitTX = wallTranslateX;
                            pinchInitTY = wallTranslateY;
                            return;
                        }

                        const dist = getTouchDist(e.touches);
                        let newScale = pinchInitScale * (dist / pinchInitDist);
                        newScale = Math.max(0.2, Math.min(3, newScale));

                        // ä»¥åŒæŒ‡ä¸­ç‚¹ä¸ºé”šç‚¹ç¼©æ”¾
                        const mid = getTouchMidpoint(e.touches);
                        const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                        // é”šç‚¹åœ¨å¢™åæ ‡ç³»çš„ä½ç½®ï¼ˆç›¸å¯¹åˆå§‹æ—¶ï¼‰
                        const anchorWallX = (pinchInitMidX - vw/2 - pinchInitTX) / pinchInitScale;
                        const anchorWallY = (pinchInitMidY - vh/2 - pinchInitTY) / pinchInitScale;
                        // æ–°å¹³ç§» = åˆå§‹å¹³ç§» + é”šç‚¹åç§» + ä¸­ç‚¹ç§»åŠ¨
                        wallTranslateX = pinchInitTX - anchorWallX * (newScale - pinchInitScale) + (mid.x - pinchInitMidX);
                        wallTranslateY = pinchInitTY - anchorWallY * (newScale - pinchInitScale) + (mid.y - pinchInitMidY);

                        // é™åˆ¶èŒƒå›´
                        const scaledW = WALL_WIDTH * newScale, scaledH = WALL_HEIGHT * newScale;
                        const maxX = Math.max(0, (scaledW - vw) / 2);
                        const maxY = Math.max(0, (scaledH - vh) / 2);
                        wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                        wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));

                        applyWallTransform(newScale);
                        currentScale = newScale;
                        slider.value = newScale;
                        zoomSpan.innerText = Math.round(newScale * 100) + '%';
                    }
                }

                function onTouchEnd(e) {
                    if (e.touches.length === 0) {
                        touchState = 'idle';
                    } else if (e.touches.length === 1 && touchState === 'pinch') {
                        touchState = 'drag';
                        dragStartX = e.touches[0].clientX;
                        dragStartY = e.touches[0].clientY;
                        dragInitTX = wallTranslateX;
                        dragInitTY = wallTranslateY;
                    }
                }

                wrapper.addEventListener('touchstart', onTouchStart, { passive: false });
                wall.addEventListener('touchstart',    onTouchStart, { passive: false });
                // move/end æŒ‚åœ¨ documentï¼Œé¿å…æ‰‹æŒ‡åˆ’å‡º wrapper æ—¶ä¸¢å¤±äº‹ä»¶
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('touchend',  onTouchEnd,  { passive: true });
                document.addEventListener('touchcancel', onTouchEnd, { passive: true });
            }

            // zoom-control é˜»æ­¢è§¦æ‘¸äº‹ä»¶å†’æ³¡åˆ° wrapperï¼ˆé˜²æ­¢æ»‘å—æ“ä½œè§¦å‘å¢™é¢æ‹–åŠ¨ï¼‰
            document.querySelector('.zoom-control').addEventListener('touchstart', (e) => {
                e.stopPropagation();
            }, { passive: true });
            document.querySelector('.zoom-control').addEventListener('touchmove', (e) => {
                e.stopPropagation();
            }, { passive: true });

            // å¼¹çª—æ§åˆ¶
            const modal = document.getElementById('infoModal');
            const closeBtn = document.getElementById('closeModalBtn');
            closeBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
            });
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                }
            });

            // é¼ æ ‡æ»šè½®ç¼©æ”¾ï¼ˆpassive:false å…è®¸ preventDefaultï¼ŒrAF èŠ‚æµé¿å…è¿ç»­å¸§å †ç§¯ï¼‰
            let wheelRafId = null;
            let wheelRafId = null;
            wrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                cursorPos.x = e.clientX;
                cursorPos.y = e.clientY;
                const delta = e.deltaY > 0 ? -0.05 : 0.05;
                let newScale = Math.max(0.2, Math.min(3, currentScale + delta));
                
                if (wheelRafId) return;
                wheelRafId = requestAnimationFrame(() => {
                    updateZoom(newScale, true);  // æ¡Œé¢ç«¯ç”¨å…‰æ ‡è·Ÿéš
                    wheelRafId = null;
                });
            }, { passive: false });

            // åŒæŒ‡ç¼©æ”¾å·²æ•´åˆè‡³ makeWallDraggable() çš„ç»Ÿä¸€æ‰‹åŠ¿ç®¡ç†å™¨

            // çª—å£resizeæ—¶ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´æ»šåŠ¨è¾¹ç•Œ (ä¿æŒä¸­å¿ƒç‚¹ï¼Ÿä¸ºäº†ç®€åŒ–ï¼Œä¸åšé¢å¤–å¤„ç†ï¼Œä½†å¯ä¿æŒç¼©æ”¾ä¸å˜)
            // å¯é€‰ï¼šresize æ—¶é‡æ–°é™åˆ¶æ»šåŠ¨è¾¹ç•Œï¼Œä½†æ— éœ€æ›´æ”¹ç¼©æ”¾ã€‚
            window.addEventListener('resize', () => {
                // çª—å£å¤§å°å˜åŒ–æ—¶ï¼Œé™åˆ¶å¢™çš„å¹³ç§»èŒƒå›´
                const vw = wrapper.clientWidth, vh = wrapper.clientHeight;
                const scaledW = WALL_WIDTH * currentScale, scaledH = WALL_HEIGHT * currentScale;
                const maxX = Math.max(0, (scaledW - vw) / 2);
                const maxY = Math.max(0, (scaledH - vh) / 2);
                wallTranslateX = Math.max(-maxX, Math.min(maxX, wallTranslateX));
                wallTranslateY = Math.max(-maxY, Math.min(maxY, wallTranslateY));
                applyWallTransform(currentScale);
                if (allNotesData.length > 50) scheduleViewportCheck();
            });
        })();
    </script>




    <!-- å¯¼èˆªå›¾æ ‡ -->
    <a href="https://www.nekt.qzz.io" target="_blank" class="nav-icon home-icon" title="è¿”å›é¦–é¡µ">
        <svg viewBox="0 0 24 24">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
    </a>
    
    <div class="nav-icon search-icon" id="searchIcon" title="æœç´¢ä¾¿ç­¾">
        <svg viewBox="0 0 24 24">
            <path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
        </svg>
    </div>
    
    <div class="nav-icon help-icon" id="helpIcon" title="å…³äº">
        <svg viewBox="0 0 24 24">
            <path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"/>
        </svg>
    </div>

    <!-- æœç´¢é¢æ¿ -->
    <div class="search-panel" id="searchPanel">
        <input type="text" id="searchInput" placeholder="æœç´¢ä¾¿ç­¾å†…å®¹..." />
        <div class="search-results" id="searchResults"></div>
    </div>
    <!-- åŠ è½½æç¤º -->
    <div id="loadingHint" style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); 
         background:rgba(45,36,30,0.95); color:#f7d9a0; padding:20px 32px; border-radius:16px;
         font-family:'Segoe UI',sans-serif; font-size:1rem; z-index:30000; pointer-events:none;
         box-shadow:0 8px 32px rgba(0,0,0,0.6); display:none;">
        <div style="text-align:center;">
            <div style="font-size:2rem; margin-bottom:8px;">ğŸ§±</div>
            <div id="loadingText">åŠ è½½ä¾¿ç­¾ä¸­...</div>
        </div>
    </div>
</body>
</html>